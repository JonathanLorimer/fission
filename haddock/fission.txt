-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package fission
@version 2.6.5

module Fission.Internal.Fixture.Entity
entity :: ToBackendKey SqlBackend model => model -> Entity model

module Fission.Internal.Fixture.Time
agesAgo :: UTCTime

module Fission.Internal.Log
logInfo :: (ToLogStr msg, MonadLogger m) => msg -> m ()
logDebug :: (ToLogStr msg, MonadLogger m) => msg -> m ()
logDebugN :: MonadLogger m => Text -> m ()
logWarn :: (ToLogStr msg, MonadLogger m) => msg -> m ()
logError :: (ToLogStr msg, MonadLogger m) => msg -> m ()
logErrorN :: MonadLogger m => Text -> m ()
logOther :: (ToLogStr msg, MonadLogger m) => LogLevel -> msg -> m ()

module Fission.Internal.MonadDB.Class
class MonadIO m => MonadDB transaction m | m -> transaction
runDB :: MonadDB transaction m => transaction a -> m a

module Fission.Internal.MonadDB.Types
type Transaction m = ReaderT SqlBackend m

module Fission.Internal.MonadDB
runDBNow :: (MonadTime m, MonadDB trans m) => (UTCTime -> trans a) -> m a
getInner :: (model -> a) -> Entity model -> a
ensureEntity :: (Exception err, MonadLogger m, MonadThrow m) => err -> Maybe a -> m a
ensureEntityM :: (Exception err, MonadLogger m, MonadThrow m) => err -> m (Maybe a) -> m a

module Fission.Internal.Orphanage.CID
instance Test.QuickCheck.Arbitrary.Arbitrary Network.IPFS.CID.Types.CID
instance Database.Persist.Class.PersistField.PersistField Network.IPFS.CID.Types.CID
instance Database.Persist.Sql.Class.PersistFieldSql Network.IPFS.CID.Types.CID

module Fission.Internal.Orphanage.ClientError
instance RIO.Prelude.Display.Display Servant.Client.Core.ClientError.ClientError

module Fission.Internal.Orphanage.OpenUnion
instance RIO.Prelude.Display.Display (Data.WorldPeace.Union.OpenUnion '[])
instance (RIO.Prelude.Display.Display a, RIO.Prelude.Display.Display (Data.WorldPeace.Union.OpenUnion as)) => RIO.Prelude.Display.Display (Data.WorldPeace.Union.OpenUnion (a : as))
instance GHC.Exception.Type.Exception (Data.WorldPeace.Union.OpenUnion '[])
instance (Data.Typeable.Internal.Typeable errs, GHC.Exception.Type.Exception err, GHC.Exception.Type.Exception (Data.WorldPeace.Union.OpenUnion errs)) => GHC.Exception.Type.Exception (Data.WorldPeace.Union.OpenUnion (err : errs))

module Fission.Internal.Orphanage.Serilaized
instance Test.QuickCheck.Arbitrary.Arbitrary Network.IPFS.File.Types.Serialized

module Fission.Internal.Orphanage.ServerError
instance RIO.Prelude.Display.Display Servant.Server.Internal.ServerError.ServerError

module Fission.Internal.Time
roundUTC :: UTCTime -> UTCTime
toSeconds :: UTCTime -> Int
fromSeconds :: Int -> UTCTime


-- | UTF8 text helpers
module Fission.Internal.UTF8
class Textable a
encode :: Textable a => a -> Either UnicodeException Text

-- | Helper for printing <a>Text</a> to a console
putText :: MonadIO m => Text -> m ()

-- | Helper for printing <a>Text</a> to a console with a newline at the end
putTextLn :: MonadIO m => Text -> m ()
displayLazyBS :: Display a => a -> ByteString

-- | Convert any binary object to <a>Text</a>
--   
--   <pre>
--   &gt;&gt;&gt; toBase58Text "hello world"
--   "StV1DL6CwTryKyV"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toBase58Text $ Strict.pack ([0x0ed, 0x01] :: [Word8] )
--   "K36"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toBase58Text $ Strict.pack ([0xed, 0x01, 0x01, 0x23, 0x45, 0x67] :: [Word8])
--   "332DkaEge"
--   </pre>
--   
--   NOTE that base58 text does not concatenate without decoding to some
--   base2 first
--   
--   <pre>
--   &gt;&gt;&gt; toBase58Text "hello world" == toBase58Text "hello " &lt;&gt; toBase58Text "world"
--   False
--   </pre>
toBase58Text :: ByteString -> Text
fromRawBytes :: [Word8] -> Text
stripOptionalPrefix :: Text -> Text -> Text
stripOptionalPrefixBS :: ByteString -> ByteString -> ByteString
stripOptionalPrefixLazyBS :: ByteString -> ByteString -> ByteString
stripOptionalSuffix :: Text -> Text -> Text
stripOptionalSuffixBS :: ByteString -> ByteString -> ByteString
stripOptionalSuffixLazyBS :: ByteString -> ByteString -> ByteString
stripPadding :: ByteString -> ByteString
stripQuotes :: Text -> Text
stripQuotesBS :: ByteString -> ByteString
stripQuotesLazyBS :: ByteString -> ByteString

-- | Remove a number of characters from the beginning and the end of some
--   text.
--   
--   <pre>
--   &gt;&gt;&gt; stripN 3 "aaabccc"
--   "b"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripN 0 "b"
--   "b"
--   </pre>
--   
--   <pre>
--   stripN n (Text.center (3 + fromIntegral n * 2) '_' "o.O") == "o.O"
--   </pre>
stripN :: Natural -> Text -> Text

-- | Remove a number of characters from the beginning and the end of a lazy
--   <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; stripNBS 3 "aaabccc"
--   "b"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripNBS 0 "b"
--   "b"
--   </pre>
stripNBS :: Natural -> ByteString -> ByteString

-- | Strip one newline character from the end of a lazy <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; stripNewline ";)\n"
--   ";)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripNewline "&lt;&gt;\n\n"
--   "&lt;&gt;\n"
--   </pre>
--   
--   <pre>
--   stripNewline (Lazy.append bs "\n") == bs
--   </pre>
--   
--   <pre>
--   stripNewline (Lazy.append bs "\n\n") == bs &lt;&gt; "\n"
--   </pre>
stripNewline :: ByteString -> ByteString

-- | Show text.
--   
--   <pre>
--   &gt;&gt;&gt; textShow 1
--   "1"
--   </pre>
textShow :: Show a => a -> Text

-- | Wrap text with some other piece of text.
--   
--   <pre>
--   Text.head (wrapIn "|" s) == '|'
--   </pre>
--   
--   <pre>
--   Text.last (wrapIn "|" s) == '|'
--   </pre>
--   
--   <pre>
--   Text.length (wrapIn "|" s) == (Text.length s) + 2
--   </pre>
wrapIn :: Text -> Text -> Text
wrapInBS :: ByteString -> ByteString -> ByteString
instance Fission.Internal.UTF8.Textable Data.ByteString.Internal.ByteString
instance Fission.Internal.UTF8.Textable Data.ByteString.Lazy.Internal.ByteString


-- | A custom <tt>Prelude</tt>-like module for this project
module Fission.Prelude
(^?) :: s -> Getting (First a) s a -> Maybe a
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
(.~) :: ASetter s t a b -> b -> s -> t
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
type LogSource = Text
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: Text -> LogLevel
logWithoutLoc :: (MonadLogger m, ToLogStr msg) => LogSource -> LogLevel -> msg -> m ()
class ToLogStr msg
toLogStr :: ToLogStr msg => msg -> LogStr
class Monad m => MonadLogger (m :: Type -> Type)
monadLoggerLog :: (MonadLogger m, ToLogStr msg) => Loc -> LogSource -> LogLevel -> msg -> m ()

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g â‰¡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b
infixr 0 `seq`

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(min(m,n))</i>. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | <i>O(n)</i>. <a>map</a> <tt>f xs</tt> is the list obtained by applying
--   <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. () => g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. () => r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 7 *
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <=
infix 4 <

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>Â±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> â‰¡ <a>id</a>
--   <a>to</a> . <a>from</a> â‰¡ <a>id</a>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | 8-bit signed integer type
data Int8

-- | 16-bit signed integer type
data Int16

-- | 32-bit signed integer type
data Int32

-- | 64-bit signed integer type
data Int64

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | 8-bit unsigned integer type
data Word8

-- | 16-bit unsigned integer type
data Word16

-- | 32-bit unsigned integer type
data Word32

-- | 64-bit unsigned integer type
data Word64

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:2:1 in interactive:Ghci1
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | Uninhabited data type
data Void

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | The basic arrow class.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a> assoc =
--   <a>arr</a> assoc &gt;&gt;&gt; <a>first</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category a => Arrow (a :: Type -> Type -> Type)

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: Arrow a => a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: Arrow a => a b c -> a (d, b) (d, c)

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 ***
infixr 3 &&&

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId

-- | A monad supporting atomic memory transactions.
data STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | A mutable variable in the <a>IO</a> monad
data IORef a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <a>Const</a> functor.
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | Left-to-right composition
(>>>) :: forall k cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | A class for categories. Instances should satisfy the laws
--   
--   <ul>
--   <li><i>Right identity</i> <tt>f <a>.</a> <a>id</a> = f</tt></li>
--   <li><i>Left identity</i> <tt><a>id</a> <a>.</a> f = f</tt></li>
--   <li><i>Associativity</i> <tt>f <a>.</a> (g <a>.</a> h) = (f <a>.</a>
--   g) <a>.</a> h</tt></li>
--   </ul>
class Category (cat :: k -> k -> Type)

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Swap bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | <i>O(min(m,n))</i>. <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <i>O(n)</i>. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) âˆ‰ {âŠ¥, <a>const</a>
--   âŠ¥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskellâ€™s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a> argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <i>O(n)</i>. Convert a <a>ShortByteString</a> into a
--   <a>ByteString</a>.
fromShort :: ShortByteString -> ByteString

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and and does
--   not contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | <a>Builder</a>s denote sequences of bytes. They are <a>Monoid</a>s
--   where <a>mempty</a> is the zero-length sequence and <a>mappend</a> is
--   concatenation, which runs in <i>O(1)</i>.
data Builder

-- | <i>O(n)</i>. Convert a <a>ByteString</a> into a
--   <a>ShortByteString</a>.
--   
--   This makes a copy, so does not retain the input string.
toShort :: ByteString -> ShortByteString

-- | A map of integers to values <tt>a</tt>.
data IntMap a

-- | A set of integers.
data IntSet

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a

-- | General-purpose finite sequences.
data Seq a

-- | A set of values <tt>a</tt>.
data Set a

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r (m :: Type -> Type) a
ReaderT :: (r -> m a) -> ReaderT r (m :: Type -> Type) a
[runReaderT] :: ReaderT r (m :: Type -> Type) a -> r -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: Reader r a -> r -> a

-- | Swap the contents of a <a>TVar</a> for a new value.
swapTVar :: TVar a -> a -> STM a

-- | Strict version of <a>modifyTVar</a>.
modifyTVar' :: TVar a -> (a -> a) -> STM ()

-- | Mutate the contents of a <a>TVar</a>. <i>N.B.</i>, this version is
--   non-strict.
modifyTVar :: TVar a -> (a -> a) -> STM ()

-- | Returns <a>True</a> if the supplied <a>TQueue</a> is empty.
isEmptyTQueue :: TQueue a -> STM Bool

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTQueue :: TQueue a -> a -> STM ()

-- | A version of <a>peekTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTQueue :: TQueue a -> STM (Maybe a)

-- | Get the next value from the <tt>TQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTQueue :: TQueue a -> STM a

-- | A version of <a>readTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTQueue :: TQueue a -> STM (Maybe a)

-- | Read the next value from the <a>TQueue</a>.
readTQueue :: TQueue a -> STM a

-- | Write a value to a <a>TQueue</a>.
writeTQueue :: TQueue a -> a -> STM ()

-- | Build and returns a new instance of <a>TQueue</a>
newTQueue :: STM (TQueue a)

-- | <a>TQueue</a> is an abstract type representing an unbounded FIFO
--   channel.
data TQueue a

-- | Check whether a given <a>TMVar</a> is empty.
isEmptyTMVar :: TMVar a -> STM Bool

-- | Swap the contents of a <a>TMVar</a> for a new value.
swapTMVar :: TMVar a -> a -> STM a

-- | A version of <a>readTMVar</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTMVar :: TMVar a -> STM (Maybe a)

-- | This is a combination of <a>takeTMVar</a> and <a>putTMVar</a>; ie. it
--   takes the value from the <a>TMVar</a>, puts it back, and also returns
--   it.
readTMVar :: TMVar a -> STM a

-- | A version of <a>putTMVar</a> that does not <a>retry</a>. The
--   <a>tryPutTMVar</a> function attempts to put the value <tt>a</tt> into
--   the <a>TMVar</a>, returning <a>True</a> if it was successful, or
--   <a>False</a> otherwise.
tryPutTMVar :: TMVar a -> a -> STM Bool

-- | Put a value into a <a>TMVar</a>. If the <a>TMVar</a> is currently
--   full, <a>putTMVar</a> will <a>retry</a>.
putTMVar :: TMVar a -> a -> STM ()

-- | A version of <a>takeTMVar</a> that does not <a>retry</a>. The
--   <a>tryTakeTMVar</a> function returns <a>Nothing</a> if the
--   <a>TMVar</a> was empty, or <tt><a>Just</a> a</tt> if the <a>TMVar</a>
--   was full with contents <tt>a</tt>. After <a>tryTakeTMVar</a>, the
--   <a>TMVar</a> is left empty.
tryTakeTMVar :: TMVar a -> STM (Maybe a)

-- | Return the contents of the <a>TMVar</a>. If the <a>TMVar</a> is
--   currently empty, the transaction will <a>retry</a>. After a
--   <a>takeTMVar</a>, the <a>TMVar</a> is left empty.
takeTMVar :: TMVar a -> STM a

-- | Create a <a>TMVar</a> which is initially empty.
newEmptyTMVar :: STM (TMVar a)

-- | Create a <a>TMVar</a> which contains the supplied value.
newTMVar :: a -> STM (TMVar a)

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a

-- | Clone a <a>TChan</a>: similar to dupTChan, but the cloned channel
--   starts with the same content available as the original channel.
cloneTChan :: TChan a -> STM (TChan a)

-- | Returns <a>True</a> if the supplied <a>TChan</a> is empty.
isEmptyTChan :: TChan a -> STM Bool

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTChan :: TChan a -> a -> STM ()

-- | Duplicate a <a>TChan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
dupTChan :: TChan a -> STM (TChan a)

-- | A version of <a>peekTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryPeekTChan :: TChan a -> STM (Maybe a)

-- | Get the next value from the <tt>TChan</tt> without removing it,
--   retrying if the channel is empty.
peekTChan :: TChan a -> STM a

-- | A version of <a>readTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTChan :: TChan a -> STM (Maybe a)

-- | Read the next value from the <a>TChan</a>.
readTChan :: TChan a -> STM a

-- | Write a value to a <a>TChan</a>.
writeTChan :: TChan a -> a -> STM ()

-- | Create a write-only <a>TChan</a>. More precisely, <a>readTChan</a>
--   will <a>retry</a> even after items have been written to the channel.
--   The only way to read a broadcast channel is to duplicate it with
--   <a>dupTChan</a>.
--   
--   Consider a server that broadcasts messages to clients:
--   
--   <pre>
--   serve :: TChan Message -&gt; Client -&gt; IO loop
--   serve broadcastChan client = do
--       myChan &lt;- dupTChan broadcastChan
--       forever $ do
--           message &lt;- readTChan myChan
--           send client message
--   </pre>
--   
--   The problem with using <a>newTChan</a> to create the broadcast channel
--   is that if it is only written to and never read, items will pile up in
--   memory. By using <a>newBroadcastTChan</a> to create the broadcast
--   channel, items can be garbage collected after clients have seen them.
newBroadcastTChan :: STM (TChan a)

-- | Build and return a new instance of <a>TChan</a>
newTChan :: STM (TChan a)

-- | <a>TChan</a> is an abstract type representing an unbounded FIFO
--   channel.
data TChan a

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is full.
isFullTBQueue :: TBQueue a -> STM Bool

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is empty.
isEmptyTBQueue :: TBQueue a -> STM Bool

-- | Put a data item back onto a channel, where it will be the next item
--   read. Blocks if the queue is full.
unGetTBQueue :: TBQueue a -> a -> STM ()

-- | A version of <a>peekTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTBQueue :: TBQueue a -> STM (Maybe a)

-- | Get the next value from the <tt>TBQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTBQueue :: TBQueue a -> STM a

-- | A version of <a>readTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTBQueue :: TBQueue a -> STM (Maybe a)

-- | Read the next value from the <a>TBQueue</a>.
readTBQueue :: TBQueue a -> STM a

-- | Write a value to a <a>TBQueue</a>; blocks if the queue is full.
writeTBQueue :: TBQueue a -> a -> STM ()

-- | Builds and returns a new instance of <a>TBQueue</a>.
newTBQueue :: Natural -> STM (TBQueue a)

-- | <a>TBQueue</a> is an abstract type representing a bounded FIFO
--   channel.
data TBQueue a

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

-- | Encode text to a ByteString <a>Builder</a> using UTF-8 encoding.
encodeUtf8Builder :: Text -> Builder

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   If the input contains any invalid UTF-8 data, the relevant exception
--   will be returned, otherwise the decoded text.
decodeUtf8' :: ByteString -> Either UnicodeException Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   <b>NOTE</b>: The replacement character returned by
--   <a>OnDecodeError</a> MUST be within the BMP plane; surrogate code
--   points will automatically be remapped to the replacement char
--   <tt>U+FFFD</tt> (<i>since 0.11.3.0</i>), whereas code points beyond
--   the BMP will throw an <a>error</a> (<i>since 1.2.3.1</i>); For earlier
--   versions of <tt>text</tt> using those unsupported code points would
--   result in undefined behavior.
decodeUtf8With :: OnDecodeError -> ByteString -> Text

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | Replace an invalid input byte with the Unicode replacement character
--   U+FFFD.
lenientDecode :: OnDecodeError

-- | An exception type for representing Unicode encoding errors.
data UnicodeException

-- | Could not decode a byte sequence because it was invalid under the
--   given encoding, or ran out of input in mid-decode.
DecodeError :: String -> Maybe Word8 -> UnicodeException

-- | Tried to encode a character that could not be represented under the
--   given encoding, or ran out of input in mid-encode.
EncodeError :: String -> Maybe Char -> UnicodeException
data Vector a
type family PrimState (m :: Type -> Type)
class (Vector Vector a, MVector MVector a) => Unbox a
class Monad m => PrimMonad (m :: Type -> Type) where {
    type family PrimState (m :: Type -> Type);
}
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a
class Hashable a
data HashMap k v
data HashSet a
class Monad m => MonadThrow (m :: Type -> Type)
throwM :: (MonadThrow m, Exception e) => e -> m a
class MonadIO m => MonadUnliftIO (m :: Type -> Type)
askUnliftIO :: MonadUnliftIO m => m (UnliftIO m)
withRunInIO :: MonadUnliftIO m => ((forall a. () => m a -> IO a) -> IO b) -> m b
newtype UnliftIO (m :: Type -> Type)
UnliftIO :: (forall a. () => m a -> IO a) -> UnliftIO (m :: Type -> Type)
[unliftIO] :: UnliftIO (m :: Type -> Type) -> forall a. () => m a -> IO a
pollSTM :: Async a -> STM (Maybe (Either SomeException a))
waitAnyCatchSTM :: [Async a] -> STM (Async a, Either SomeException a)
waitAnySTM :: [Async a] -> STM (Async a, a)
waitBothSTM :: Async a -> Async b -> STM (a, b)
waitCatchSTM :: Async a -> STM (Either SomeException a)
waitEitherCatchSTM :: Async a -> Async b -> STM (Either (Either SomeException a) (Either SomeException b))
waitEitherSTM :: Async a -> Async b -> STM (Either a b)
waitEitherSTM_ :: Async a -> Async b -> STM ()
waitSTM :: Async a -> STM a
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
over :: ASetter s t a b -> (a -> b) -> s -> t
set :: ASetter s t a b -> b -> s -> t
to :: (s -> a) -> SimpleGetter s a
sets :: ((a -> b) -> s -> t) -> ASetter s t a b
asBDeque :: BDeque s a -> BDeque s a
asSDeque :: SDeque s a -> SDeque s a
asUDeque :: UDeque s a -> UDeque s a
dequeToList :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m [a]
dequeToVector :: forall v' a (v :: Type -> Type -> Type) m. (Vector v' a, MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (v' a)
foldlDeque :: forall (v :: Type -> Type -> Type) a m acc. (MVector v a, PrimMonad m) => (acc -> a -> m acc) -> acc -> Deque v (PrimState m) a -> m acc
foldrDeque :: forall (v :: Type -> Type -> Type) a m acc. (MVector v a, PrimMonad m) => (a -> acc -> m acc) -> acc -> Deque v (PrimState m) a -> m acc
freezeDeque :: (Vector v a, PrimMonad m) => Deque (Mutable v) (PrimState m) a -> m (v a)
getDequeSize :: forall m (v :: Type -> Type -> Type) a. PrimMonad m => Deque v (PrimState m) a -> m Int
newDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => m (Deque v (PrimState m) a)
popBackDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (Maybe a)
popFrontDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (Maybe a)
pushBackDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> a -> m ()
pushFrontDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> a -> m ()
displayBytesUtf8 :: ByteString -> Utf8Builder
displayShow :: Show a => a -> Utf8Builder
utf8BuilderToLazyText :: Utf8Builder -> Text
utf8BuilderToText :: Utf8Builder -> Text
writeFileUtf8Builder :: MonadIO m => FilePath -> Utf8Builder -> m ()
exitFailure :: MonadIO m => m a
exitSuccess :: MonadIO m => m a
exitWith :: MonadIO m => ExitCode -> m a
asIO :: IO a -> IO a
foldMapM :: (Monad m, Monoid w, Foldable t) => (a -> m w) -> t a -> m w
forMaybeA :: Applicative f => [a] -> (a -> f (Maybe b)) -> f [b]
forMaybeM :: Monad m => [a] -> (a -> m (Maybe b)) -> m [b]
fromFirst :: a -> First a -> a
mapLeft :: (a1 -> a2) -> Either a1 b -> Either a2 b
mapMaybeA :: Applicative f => (a -> f (Maybe b)) -> [a] -> f [b]
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]
nubOrd :: Ord a => [a] -> [a]
unlessM :: Monad m => m Bool -> m () -> m ()
whenM :: Monad m => m Bool -> m () -> m ()
hPutBuilder :: MonadIO m => Handle -> Builder -> m ()
readFileBinary :: MonadIO m => FilePath -> m ByteString
readFileUtf8 :: MonadIO m => FilePath -> m Text
withLazyFile :: MonadUnliftIO m => FilePath -> (ByteString -> m a) -> m a
withLazyFileUtf8 :: MonadUnliftIO m => FilePath -> (Text -> m a) -> m a
writeFileBinary :: MonadIO m => FilePath -> ByteString -> m ()
writeFileUtf8 :: MonadIO m => FilePath -> Text -> m ()
view :: MonadReader s m => Getting a s a -> m a
contramapGLogFunc :: (a -> b) -> GLogFunc b -> GLogFunc a
contramapMaybeGLogFunc :: (a -> Maybe b) -> GLogFunc b -> GLogFunc a
displayCallStack :: CallStack -> Utf8Builder
gLogFuncClassic :: (HasLogLevel msg, HasLogSource msg, Display msg) => LogFunc -> GLogFunc msg
glog :: (MonadIO m, HasCallStack, HasGLogFunc env, MonadReader env m) => GMsg env -> m ()
logFuncUseColorL :: HasLogFunc env => SimpleGetter env Bool
logGeneric :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> LogLevel -> Utf8Builder -> m ()
logOptionsHandle :: MonadIO m => Handle -> Bool -> m LogOptions
logOptionsMemory :: MonadIO m => m (IORef Builder, LogOptions)
logSticky :: (MonadIO m, HasCallStack, MonadReader env m, HasLogFunc env) => Utf8Builder -> m ()
logStickyDone :: (MonadIO m, HasCallStack, MonadReader env m, HasLogFunc env) => Utf8Builder -> m ()
mkGLogFunc :: (CallStack -> msg -> IO ()) -> GLogFunc msg
mkLogFunc :: (CallStack -> LogSource -> LogLevel -> Utf8Builder -> IO ()) -> LogFunc
newLogFunc :: (MonadIO n, MonadIO m) => LogOptions -> n (LogFunc, m ())
noLogging :: (HasLogFunc env, MonadReader env m) => m a -> m a
setLogFormat :: (Utf8Builder -> Utf8Builder) -> LogOptions -> LogOptions
setLogMinLevel :: LogLevel -> LogOptions -> LogOptions
setLogMinLevelIO :: IO LogLevel -> LogOptions -> LogOptions
setLogTerminal :: Bool -> LogOptions -> LogOptions
setLogUseColor :: Bool -> LogOptions -> LogOptions
setLogUseLoc :: Bool -> LogOptions -> LogOptions
setLogUseTime :: Bool -> LogOptions -> LogOptions
setLogVerboseFormat :: Bool -> LogOptions -> LogOptions
setLogVerboseFormatIO :: IO Bool -> LogOptions -> LogOptions
withLogFunc :: MonadUnliftIO m => LogOptions -> (LogFunc -> m a) -> m a
liftRIO :: (MonadIO m, MonadReader env m) => RIO env a -> m a
mapRIO :: (outer -> inner) -> RIO inner a -> RIO outer a
modifySomeRef :: MonadIO m => SomeRef a -> (a -> a) -> m ()
newSomeRef :: MonadIO m => a -> m (SomeRef a)
newUnboxedSomeRef :: (MonadIO m, Unbox a) => a -> m (SomeRef a)
readSomeRef :: MonadIO m => SomeRef a -> m a
runRIO :: MonadIO m => env -> RIO env a -> m a
writeSomeRef :: MonadIO m => SomeRef a -> a -> m ()
fromStrictBytes :: ByteString -> LByteString
sappend :: Semigroup s => s -> s -> s
toStrictBytes :: LByteString -> ByteString
yieldThread :: MonadIO m => m ()
mkSimpleApp :: MonadIO m => LogFunc -> Maybe ProcessContext -> m SimpleApp
runSimpleApp :: MonadIO m => RIO SimpleApp a -> m a
decodeUtf8Lenient :: ByteString -> Text
tshow :: Show a => a -> Text
trace :: Text -> a -> a
traceDisplay :: Display a => a -> b -> b
traceDisplayEvent :: Display a => a -> b -> b
traceDisplayEventIO :: (Display a, MonadIO m) => a -> m ()
traceDisplayIO :: (Display a, MonadIO m) => a -> m ()
traceDisplayId :: Display a => a -> a
traceDisplayM :: (Display a, Applicative f) => a -> f ()
traceDisplayMarker :: Display a => a -> b -> b
traceDisplayMarkerIO :: (Display a, MonadIO m) => a -> m ()
traceDisplayStack :: Display a => a -> b -> b
traceEvent :: Text -> a -> a
traceEventIO :: MonadIO m => Text -> m ()
traceIO :: MonadIO m => Text -> m ()
traceId :: Text -> Text
traceM :: Applicative f => Text -> f ()
traceMarker :: Text -> a -> a
traceMarkerIO :: MonadIO m => Text -> m ()
traceShow :: Show a => a -> b -> b
traceShowEvent :: Show a => a -> b -> b
traceShowEventIO :: (Show a, MonadIO m) => a -> m ()
traceShowIO :: (Show a, MonadIO m) => a -> m ()
traceShowId :: Show a => a -> a
traceShowM :: (Show a, Applicative f) => a -> f ()
traceShowMarker :: Show a => a -> b -> b
traceShowMarkerIO :: (Show a, MonadIO m) => a -> m ()
traceShowStack :: Show a => a -> b -> b
traceStack :: Text -> a -> a
modifyURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> (a -> a) -> m ()
newURef :: (PrimMonad m, Unbox a) => a -> m (URef (PrimState m) a)
readURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> m a
writeURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> a -> m ()
dupChan :: MonadIO m => Chan a -> m (Chan a)
getChanContents :: MonadIO m => Chan a -> m [a]
newChan :: MonadIO m => m (Chan a)
readChan :: MonadIO m => Chan a -> m a
writeChan :: MonadIO m => Chan a -> a -> m ()
writeList2Chan :: MonadIO m => Chan a -> [a] -> m ()
isCurrentThreadBound :: MonadIO m => m Bool
myThreadId :: MonadIO m => m ThreadId
threadDelay :: MonadIO m => Int -> m ()
threadWaitRead :: MonadIO m => Fd -> m ()
threadWaitWrite :: MonadIO m => Fd -> m ()
bracket :: MonadUnliftIO m => m a -> (a -> m b) -> (a -> m c) -> m c
bracketOnError :: MonadUnliftIO m => m a -> (a -> m b) -> (a -> m c) -> m c
bracketOnError_ :: MonadUnliftIO m => m a -> m b -> m c -> m c
bracket_ :: MonadUnliftIO m => m a -> m b -> m c -> m c
catch :: (MonadUnliftIO m, Exception e) => m a -> (e -> m a) -> m a
catchAny :: MonadUnliftIO m => m a -> (SomeException -> m a) -> m a
catchAnyDeep :: (NFData a, MonadUnliftIO m) => m a -> (SomeException -> m a) -> m a
catchDeep :: (MonadUnliftIO m, Exception e, NFData a) => m a -> (e -> m a) -> m a
catchIO :: MonadUnliftIO m => m a -> (IOException -> m a) -> m a
catchJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a
catches :: MonadUnliftIO m => m a -> [Handler m a] -> m a
catchesDeep :: (MonadUnliftIO m, NFData a) => m a -> [Handler m a] -> m a
evaluate :: MonadIO m => a -> m a
evaluateDeep :: (MonadIO m, NFData a) => a -> m a
finally :: MonadUnliftIO m => m a -> m b -> m a
fromEither :: (Exception e, MonadIO m) => Either e a -> m a
fromEitherIO :: (Exception e, MonadIO m) => IO (Either e a) -> m a
fromEitherM :: (Exception e, MonadIO m) => m (Either e a) -> m a
handle :: (MonadUnliftIO m, Exception e) => (e -> m a) -> m a -> m a
handleAny :: MonadUnliftIO m => (SomeException -> m a) -> m a -> m a
handleAnyDeep :: (MonadUnliftIO m, NFData a) => (SomeException -> m a) -> m a -> m a
handleDeep :: (MonadUnliftIO m, Exception e, NFData a) => (e -> m a) -> m a -> m a
handleIO :: MonadUnliftIO m => (IOException -> m a) -> m a -> m a
handleJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a
impureThrow :: Exception e => e -> a
isAsyncException :: Exception e => e -> Bool
isSyncException :: Exception e => e -> Bool
mask :: MonadUnliftIO m => ((forall a. () => m a -> m a) -> m b) -> m b
mask_ :: MonadUnliftIO m => m a -> m a
onException :: MonadUnliftIO m => m a -> m b -> m a
pureTry :: a -> Either SomeException a
pureTryDeep :: NFData a => a -> Either SomeException a
stringException :: HasCallStack => String -> StringException
throwIO :: (MonadIO m, Exception e) => e -> m a
throwString :: (MonadIO m, HasCallStack) => String -> m a
throwTo :: (Exception e, MonadIO m) => ThreadId -> e -> m ()
toAsyncException :: Exception e => e -> SomeException
toSyncException :: Exception e => e -> SomeException
try :: (MonadUnliftIO m, Exception e) => m a -> m (Either e a)
tryAny :: MonadUnliftIO m => m a -> m (Either SomeException a)
tryAnyDeep :: (MonadUnliftIO m, NFData a) => m a -> m (Either SomeException a)
tryDeep :: (MonadUnliftIO m, Exception e, NFData a) => m a -> m (Either e a)
tryIO :: MonadUnliftIO m => m a -> m (Either IOException a)
tryJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)
uninterruptibleMask :: MonadUnliftIO m => ((forall a. () => m a -> m a) -> m b) -> m b
uninterruptibleMask_ :: MonadUnliftIO m => m a -> m a
withException :: (MonadUnliftIO m, Exception e) => m a -> (e -> m b) -> m a
getMonotonicTime :: MonadIO m => m Double
hClose :: MonadIO m => Handle -> m ()
hFileSize :: MonadIO m => Handle -> m Integer
hFlush :: MonadIO m => Handle -> m ()
hGetBuffering :: MonadIO m => Handle -> m BufferMode
hGetEcho :: MonadIO m => Handle -> m Bool
hIsClosed :: MonadIO m => Handle -> m Bool
hIsEOF :: MonadIO m => Handle -> m Bool
hIsOpen :: MonadIO m => Handle -> m Bool
hIsReadable :: MonadIO m => Handle -> m Bool
hIsSeekable :: MonadIO m => Handle -> m Bool
hIsTerminalDevice :: MonadIO m => Handle -> m Bool
hIsWritable :: MonadIO m => Handle -> m Bool
hReady :: MonadIO m => Handle -> m Bool
hSeek :: MonadIO m => Handle -> SeekMode -> Integer -> m ()
hSetBuffering :: MonadIO m => Handle -> BufferMode -> m ()
hSetEcho :: MonadIO m => Handle -> Bool -> m ()
hSetFileSize :: MonadIO m => Handle -> Integer -> m ()
hTell :: MonadIO m => Handle -> m Integer
hWaitForInput :: MonadIO m => Handle -> Int -> m Bool
withBinaryFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a
withFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a
atomicModifyIORef :: MonadIO m => IORef a -> (a -> (a, b)) -> m b
atomicModifyIORef' :: MonadIO m => IORef a -> (a -> (a, b)) -> m b
atomicWriteIORef :: MonadIO m => IORef a -> a -> m ()
mkWeakIORef :: MonadUnliftIO m => IORef a -> m () -> m (Weak (IORef a))
modifyIORef :: MonadIO m => IORef a -> (a -> a) -> m ()
modifyIORef' :: MonadIO m => IORef a -> (a -> a) -> m ()
newIORef :: MonadIO m => a -> m (IORef a)
readIORef :: MonadIO m => IORef a -> m a
writeIORef :: MonadIO m => IORef a -> a -> m ()
async :: MonadUnliftIO m => m a -> m (Async a)
asyncBound :: MonadUnliftIO m => m a -> m (Async a)
asyncOn :: MonadUnliftIO m => Int -> m a -> m (Async a)
asyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall b. () => m b -> m b) -> m a) -> m (Async a)
asyncWithUnmask :: MonadUnliftIO m => ((forall b. () => m b -> m b) -> m a) -> m (Async a)
cancel :: MonadIO m => Async a -> m ()
cancelWith :: (Exception e, MonadIO m) => Async a -> e -> m ()
conc :: m a -> Conc m a
concurrently :: MonadUnliftIO m => m a -> m b -> m (a, b)
concurrently_ :: MonadUnliftIO m => m a -> m b -> m ()
forConcurrently :: (MonadUnliftIO m, Traversable t) => t a -> (a -> m b) -> m (t b)
forConcurrently_ :: (MonadUnliftIO m, Foldable f) => f a -> (a -> m b) -> m ()
link :: MonadIO m => Async a -> m ()
link2 :: MonadIO m => Async a -> Async b -> m ()
mapConcurrently :: (MonadUnliftIO m, Traversable t) => (a -> m b) -> t a -> m (t b)
mapConcurrently_ :: (MonadUnliftIO m, Foldable f) => (a -> m b) -> f a -> m ()
poll :: MonadIO m => Async a -> m (Maybe (Either SomeException a))
pooledForConcurrently :: (MonadUnliftIO m, Traversable t) => t a -> (a -> m b) -> m (t b)
pooledForConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> t a -> (a -> m b) -> m (t b)
pooledForConcurrentlyN_ :: (MonadUnliftIO m, Foldable t) => Int -> t a -> (a -> m b) -> m ()
pooledForConcurrently_ :: (MonadUnliftIO m, Foldable f) => f a -> (a -> m b) -> m ()
pooledMapConcurrently :: (MonadUnliftIO m, Traversable t) => (a -> m b) -> t a -> m (t b)
pooledMapConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> (a -> m b) -> t a -> m (t b)
pooledMapConcurrentlyN_ :: (MonadUnliftIO m, Foldable f) => Int -> (a -> m b) -> f a -> m ()
pooledMapConcurrently_ :: (MonadUnliftIO m, Foldable f) => (a -> m b) -> f a -> m ()
pooledReplicateConcurrently :: MonadUnliftIO m => Int -> m a -> m [a]
pooledReplicateConcurrentlyN :: MonadUnliftIO m => Int -> Int -> m a -> m [a]
pooledReplicateConcurrentlyN_ :: MonadUnliftIO m => Int -> Int -> m a -> m ()
pooledReplicateConcurrently_ :: MonadUnliftIO m => Int -> m a -> m ()
race :: MonadUnliftIO m => m a -> m b -> m (Either a b)
race_ :: MonadUnliftIO m => m a -> m b -> m ()
replicateConcurrently :: MonadUnliftIO m => Int -> m b -> m [b]
replicateConcurrently_ :: (Applicative m, MonadUnliftIO m) => Int -> m a -> m ()
runConc :: MonadUnliftIO m => Conc m a -> m a
uninterruptibleCancel :: MonadIO m => Async a -> m ()
wait :: MonadIO m => Async a -> m a
waitAny :: MonadIO m => [Async a] -> m (Async a, a)
waitAnyCancel :: MonadIO m => [Async a] -> m (Async a, a)
waitAnyCatch :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)
waitAnyCatchCancel :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)
waitBoth :: MonadIO m => Async a -> Async b -> m (a, b)
waitCatch :: MonadIO m => Async a -> m (Either SomeException a)
waitEither :: MonadIO m => Async a -> Async b -> m (Either a b)
waitEitherCancel :: MonadIO m => Async a -> Async b -> m (Either a b)
waitEitherCatch :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))
waitEitherCatchCancel :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))
waitEither_ :: MonadIO m => Async a -> Async b -> m ()
withAsync :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b
withAsyncBound :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b
withAsyncOn :: MonadUnliftIO m => Int -> m a -> (Async a -> m b) -> m b
withAsyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall c. () => m c -> m c) -> m a) -> (Async a -> m b) -> m b
withAsyncWithUnmask :: MonadUnliftIO m => ((forall c. () => m c -> m c) -> m a) -> (Async a -> m b) -> m b
isEmptyMVar :: MonadIO m => MVar a -> m Bool
mkWeakMVar :: MonadUnliftIO m => MVar a -> m () -> m (Weak (MVar a))
modifyMVar :: MonadUnliftIO m => MVar a -> (a -> m (a, b)) -> m b
modifyMVarMasked :: MonadUnliftIO m => MVar a -> (a -> m (a, b)) -> m b
modifyMVarMasked_ :: MonadUnliftIO m => MVar a -> (a -> m a) -> m ()
modifyMVar_ :: MonadUnliftIO m => MVar a -> (a -> m a) -> m ()
newEmptyMVar :: MonadIO m => m (MVar a)
newMVar :: MonadIO m => a -> m (MVar a)
putMVar :: MonadIO m => MVar a -> a -> m ()
readMVar :: MonadIO m => MVar a -> m a
swapMVar :: MonadIO m => MVar a -> a -> m a
takeMVar :: MonadIO m => MVar a -> m a
tryPutMVar :: MonadIO m => MVar a -> a -> m Bool
tryReadMVar :: MonadIO m => MVar a -> m (Maybe a)
tryTakeMVar :: MonadIO m => MVar a -> m (Maybe a)
withMVar :: MonadUnliftIO m => MVar a -> (a -> m b) -> m b
withMVarMasked :: MonadUnliftIO m => MVar a -> (a -> m b) -> m b
memoizeMVar :: MonadUnliftIO m => m a -> m (Memoized a)
memoizeRef :: MonadUnliftIO m => m a -> m (Memoized a)
runMemoized :: MonadIO m => Memoized a -> m a
atomically :: MonadIO m => STM a -> m a
checkSTM :: Bool -> STM ()
mkWeakTMVar :: MonadUnliftIO m => TMVar a -> m () -> m (Weak (TMVar a))
mkWeakTVar :: MonadUnliftIO m => TVar a -> m () -> m (Weak (TVar a))
newBroadcastTChanIO :: MonadIO m => m (TChan a)
newEmptyTMVarIO :: MonadIO m => m (TMVar a)
newTBQueueIO :: MonadIO m => Natural -> m (TBQueue a)
newTChanIO :: MonadIO m => m (TChan a)
newTMVarIO :: MonadIO m => a -> m (TMVar a)
newTQueueIO :: MonadIO m => m (TQueue a)
newTVarIO :: MonadIO m => a -> m (TVar a)
readTVarIO :: MonadIO m => TVar a -> m a
registerDelay :: MonadIO m => Int -> m (TVar Bool)
retrySTM :: STM a
withSystemTempDirectory :: MonadUnliftIO m => String -> (FilePath -> m a) -> m a
withSystemTempFile :: MonadUnliftIO m => String -> (FilePath -> Handle -> m a) -> m a
withTempDirectory :: MonadUnliftIO m => FilePath -> String -> (FilePath -> m a) -> m a
withTempFile :: MonadUnliftIO m => FilePath -> String -> (FilePath -> Handle -> m a) -> m a
askRunInIO :: MonadUnliftIO m => m (m a -> IO a)
toIO :: MonadUnliftIO m => m a -> m (IO a)
withUnliftIO :: MonadUnliftIO m => (UnliftIO m -> IO a) -> m a
wrappedWithRunInIO :: MonadUnliftIO n => (n b -> m b) -> (forall a. () => m a -> n a) -> ((forall a. () => m a -> IO a) -> IO b) -> m b
data Async a
type ASetter s t a b = a -> Identity b -> s -> Identity t
type ASetter' s a = ASetter s s a a
type Getting r s a = a -> Const r a -> s -> Const r s
type Lens s t a b = forall (f :: Type -> Type). Functor f => a -> f b -> s -> f t
type Lens' s a = Lens s s a a
type SimpleGetter s a = forall r. () => Getting r s a
type BDeque = Deque MVector
data Deque (v :: Type -> Type -> Type) s a
type SDeque = Deque MVector
type UDeque = Deque MVector
class Display a
display :: Display a => a -> Utf8Builder
textDisplay :: Display a => a -> Text
newtype Utf8Builder
Utf8Builder :: Builder -> Utf8Builder
[getUtf8Builder] :: Utf8Builder -> Builder
data GLogFunc msg
type family GMsg env
class HasGLogFunc env where {
    type family GMsg env;
}
gLogFuncL :: HasGLogFunc env => Lens' env (GLogFunc (GMsg env))
class HasLogFunc env
logFuncL :: HasLogFunc env => Lens' env LogFunc
class HasLogLevel msg
getLogLevel :: HasLogLevel msg => msg -> LogLevel
class HasLogSource msg
getLogSource :: HasLogSource msg => msg -> LogSource
data LogFunc
data LogOptions
class HasStateRef s env | env -> s
stateRefL :: HasStateRef s env => Lens' env (SomeRef s)
class HasWriteRef w env | env -> w
writeRefL :: HasWriteRef w env => Lens' env (SomeRef w)
newtype RIO env a
RIO :: ReaderT env IO a -> RIO env a
[unRIO] :: RIO env a -> ReaderT env IO a
data SomeRef a
type GVector = Vector
type LByteString = ByteString
type LText = Text
type SVector = Vector
type UVector = Vector
data SimpleApp
type IOURef = URef PrimState IO
data URef s a
data AsyncExceptionWrapper
AsyncExceptionWrapper :: e -> AsyncExceptionWrapper
data StringException
StringException :: String -> CallStack -> StringException
data SyncExceptionWrapper
SyncExceptionWrapper :: e -> SyncExceptionWrapper
data Conc (m :: Type -> Type) a
data ConcException
EmptyWithNoAlternative :: ConcException
newtype Concurrently (m :: Type -> Type) a
Concurrently :: m a -> Concurrently (m :: Type -> Type) a
[runConcurrently] :: Concurrently (m :: Type -> Type) a -> m a
data Memoized a
allProperties :: Q Exp
forAllProperties :: Q Exp
monomorphic :: Name -> ExpQ
polyQuickCheck :: Name -> ExpQ
polyVerboseCheck :: Name -> ExpQ
quickCheckAll :: Q Exp
verboseCheckAll :: Q Exp
(><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
applyArbitrary2 :: (Arbitrary a, Arbitrary b) => (a -> b -> r) -> Gen r
applyArbitrary3 :: (Arbitrary a, Arbitrary b, Arbitrary c) => (a -> b -> c -> r) -> Gen r
applyArbitrary4 :: (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => (a -> b -> c -> d -> r) -> Gen r
arbitrary1 :: (Arbitrary1 f, Arbitrary a) => Gen (f a)
arbitrary2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => Gen (f a b)
arbitraryASCIIChar :: Gen Char
arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a
arbitraryBoundedIntegral :: (Bounded a, Integral a) => Gen a
arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a
arbitraryPrintableChar :: Gen Char
arbitrarySizedBoundedIntegral :: (Bounded a, Integral a) => Gen a
arbitrarySizedFractional :: Fractional a => Gen a
arbitrarySizedIntegral :: Integral a => Gen a
arbitrarySizedNatural :: Integral a => Gen a
arbitraryUnicodeChar :: Gen Char
coarbitraryEnum :: Enum a => a -> Gen b -> Gen b
coarbitraryIntegral :: Integral a => a -> Gen b -> Gen b
coarbitraryReal :: Real a => a -> Gen b -> Gen b
coarbitraryShow :: Show a => a -> Gen b -> Gen b
genericCoarbitrary :: (Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b
genericShrink :: (Generic a, RecursivelyShrink (Rep a), GSubterms (Rep a) a) => a -> [a]
infiniteList :: Arbitrary a => Gen [a]
orderedList :: (Ord a, Arbitrary a) => Gen [a]
recursivelyShrink :: (Generic a, RecursivelyShrink (Rep a)) => a -> [a]
shrink1 :: (Arbitrary1 f, Arbitrary a) => f a -> [f a]
shrink2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => f a b -> [f a b]
shrinkDecimal :: RealFrac a => a -> [a]
shrinkIntegral :: Integral a => a -> [a]
shrinkList :: (a -> [a]) -> [a] -> [[a]]
shrinkMap :: Arbitrary a => (a -> b) -> (b -> a) -> b -> [b]
shrinkMapBy :: (a -> b) -> (b -> a) -> (a -> [a]) -> b -> [b]
shrinkNothing :: a -> [a]
shrinkRealFrac :: RealFrac a => a -> [a]
subterms :: (Generic a, GSubterms (Rep a) a) => a -> [a]
vector :: Arbitrary a => Int -> Gen [a]
discard :: a
labelledExamples :: Testable prop => prop -> IO ()
labelledExamplesResult :: Testable prop => prop -> IO Result
labelledExamplesWith :: Testable prop => Args -> prop -> IO ()
labelledExamplesWithResult :: Testable prop => Args -> prop -> IO Result
pattern Fn :: (a -> b) -> Fun a b
pattern Fn2 :: (a -> b -> c) -> Fun (a, b) c
pattern Fn3 :: (a -> b -> c -> d) -> Fun (a, b, c) d
applyFun :: Fun a b -> a -> b
applyFun2 :: Fun (a, b) c -> a -> b -> c
applyFun3 :: Fun (a, b, c) d -> a -> b -> c -> d
functionBoundedEnum :: (Eq a, Bounded a, Enum a) => (a -> b) -> a :-> b
functionIntegral :: Integral a => (a -> b) -> a :-> b
functionMap :: Function b => (a -> b) -> (b -> a) -> (a -> c) -> a :-> c
functionRealFrac :: RealFrac a => (a -> b) -> a :-> b
functionShow :: (Show a, Read a) => (a -> c) -> a :-> c
functionVoid :: (forall b. () => void -> b) -> void :-> c
choose :: Random a => (a, a) -> Gen a
elements :: [a] -> Gen a
frequency :: [(Int, Gen a)] -> Gen a
generate :: Gen a -> IO a
getSize :: Gen Int
growingElements :: [a] -> Gen a
infiniteListOf :: Gen a -> Gen [a]
listOf :: Gen a -> Gen [a]
listOf1 :: Gen a -> Gen [a]
oneof :: [Gen a] -> Gen a
resize :: Int -> Gen a -> Gen a
sample :: Show a => Gen a -> IO ()
sample' :: Gen a -> IO [a]
scale :: (Int -> Int) -> Gen a -> Gen a
shuffle :: [a] -> Gen [a]
sized :: (Int -> Gen a) -> Gen a
sublistOf :: [a] -> Gen [a]
suchThat :: Gen a -> (a -> Bool) -> Gen a
suchThatMap :: Gen a -> (a -> Maybe b) -> Gen b
suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
variant :: Integral n => n -> Gen a -> Gen a
vectorOf :: Int -> Gen a -> Gen [a]
(.&&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
(.||.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
(=/=) :: (Eq a, Show a) => a -> a -> Property
(===) :: (Eq a, Show a) => a -> a -> Property
(==>) :: Testable prop => Bool -> prop -> Property
again :: Testable prop => prop -> Property
checkCoverage :: Testable prop => prop -> Property
checkCoverageWith :: Testable prop => Confidence -> prop -> Property
classify :: Testable prop => Bool -> String -> prop -> Property
collect :: (Show a, Testable prop) => a -> prop -> Property
conjoin :: Testable prop => [prop] -> Property
counterexample :: Testable prop => String -> prop -> Property
cover :: Testable prop => Double -> Bool -> String -> prop -> Property
coverTable :: Testable prop => String -> [(String, Double)] -> prop -> Property
disjoin :: Testable prop => [prop] -> Property
expectFailure :: Testable prop => prop -> Property
forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
forAllBlind :: Testable prop => Gen a -> (a -> prop) -> Property
forAllShow :: Testable prop => Gen a -> (a -> String) -> (a -> prop) -> Property
forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property
forAllShrinkBlind :: Testable prop => Gen a -> (a -> [a]) -> (a -> prop) -> Property
forAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> String) -> (a -> prop) -> Property
idempotentIOProperty :: Testable prop => IO prop -> Property
ioProperty :: Testable prop => IO prop -> Property
label :: Testable prop => String -> prop -> Property
mapSize :: Testable prop => (Int -> Int) -> prop -> Property
noShrinking :: Testable prop => prop -> Property
once :: Testable prop => prop -> Property
printTestCase :: Testable prop => String -> prop -> Property
shrinking :: Testable prop => (a -> [a]) -> a -> (a -> prop) -> Property
stdConfidence :: Confidence
tabulate :: Testable prop => String -> [String] -> prop -> Property
total :: NFData a => a -> Property
verbose :: Testable prop => prop -> Property
verboseShrinking :: Testable prop => prop -> Property
whenFail :: Testable prop => IO () -> prop -> Property
whenFail' :: Testable prop => IO () -> prop -> Property
withMaxSuccess :: Testable prop => Int -> prop -> Property
within :: Testable prop => Int -> prop -> Property
isSuccess :: Result -> Bool
quickCheck :: Testable prop => prop -> IO ()
quickCheckResult :: Testable prop => prop -> IO Result
quickCheckWith :: Testable prop => Args -> prop -> IO ()
quickCheckWithResult :: Testable prop => Args -> prop -> IO Result
stdArgs :: Args
verboseCheck :: Testable prop => prop -> IO ()
verboseCheckResult :: Testable prop => prop -> IO Result
verboseCheckWith :: Testable prop => Args -> prop -> IO ()
verboseCheckWithResult :: Testable prop => Args -> prop -> IO Result
class Arbitrary a
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]
class Arbitrary1 (f :: Type -> Type)
liftArbitrary :: Arbitrary1 f => Gen a -> Gen (f a)
liftShrink :: Arbitrary1 f => (a -> [a]) -> f a -> [f a]
class Arbitrary2 (f :: Type -> Type -> Type)
liftArbitrary2 :: Arbitrary2 f => Gen a -> Gen b -> Gen (f a b)
liftShrink2 :: Arbitrary2 f => (a -> [a]) -> (b -> [b]) -> f a b -> [f a b]
class CoArbitrary a
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b
data Fun a b
Fun :: (a :-> b, b, Shrunk) -> (a -> b) -> Fun a b
class Function a
function :: Function a => (a -> b) -> a :-> b
data Gen a
newtype ASCIIString
ASCIIString :: String -> ASCIIString
[getASCIIString] :: ASCIIString -> String
newtype Blind a
Blind :: a -> Blind a
[getBlind] :: Blind a -> a
newtype Fixed a
Fixed :: a -> Fixed a
[getFixed] :: Fixed a -> a
data InfiniteList a
InfiniteList :: [a] -> InfiniteListInternalData a -> InfiniteList a
[getInfiniteList] :: InfiniteList a -> [a]
[infiniteListInternalData] :: InfiniteList a -> InfiniteListInternalData a
newtype Large a
Large :: a -> Large a
[getLarge] :: Large a -> a
newtype Negative a
Negative :: a -> Negative a
[getNegative] :: Negative a -> a
newtype NonEmptyList a
NonEmpty :: [a] -> NonEmptyList a
[getNonEmpty] :: NonEmptyList a -> [a]
newtype NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a
newtype NonPositive a
NonPositive :: a -> NonPositive a
[getNonPositive] :: NonPositive a -> a
newtype NonZero a
NonZero :: a -> NonZero a
[getNonZero] :: NonZero a -> a
newtype OrderedList a
Ordered :: [a] -> OrderedList a
[getOrdered] :: OrderedList a -> [a]
newtype Positive a
Positive :: a -> Positive a
[getPositive] :: Positive a -> a
newtype PrintableString
PrintableString :: String -> PrintableString
[getPrintableString] :: PrintableString -> String
newtype Shrink2 a
Shrink2 :: a -> Shrink2 a
[getShrink2] :: Shrink2 a -> a
class ShrinkState s a
shrinkInit :: ShrinkState s a => a -> s
shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
data Shrinking s a
Shrinking :: s -> a -> Shrinking s a
newtype Small a
Small :: a -> Small a
[getSmall] :: Small a -> a
data Smart a
Smart :: Int -> a -> Smart a
newtype SortedList a
Sorted :: [a] -> SortedList a
[getSorted] :: SortedList a -> [a]
newtype UnicodeString
UnicodeString :: String -> UnicodeString
[getUnicodeString] :: UnicodeString -> String
data Discard
Discard :: Discard
data Property
class Testable prop
property :: Testable prop => prop -> Property
propertyForAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> [String]) -> (a -> prop) -> Property
data Confidence
Confidence :: Integer -> Double -> Confidence
[certainty] :: Confidence -> Integer
[tolerance] :: Confidence -> Double
data Args
Args :: Maybe (QCGen, Int) -> Int -> Int -> Int -> Bool -> Int -> Args
[replay] :: Args -> Maybe (QCGen, Int)
[maxSuccess] :: Args -> Int
[maxDiscardRatio] :: Args -> Int
[maxSize] :: Args -> Int
[chatty] :: Args -> Bool
[maxShrinks] :: Args -> Int
data Entity record
Entity :: Key record -> record -> Entity record
[entityKey] :: Entity record -> Key record
[entityVal] :: Entity record -> record
headMaybe :: [a] -> Maybe a
identity :: a -> a

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | Helper for printing <a>Text</a> to a console
putText :: MonadIO m => Text -> m ()

-- | Helper for printing <a>Text</a> to a console with a newline at the end
putTextLn :: MonadIO m => Text -> m ()

-- | Show text.
--   
--   <pre>
--   &gt;&gt;&gt; textShow 1
--   "1"
--   </pre>
textShow :: Show a => a -> Text
displayLazyBS :: Display a => a -> ByteString
bind :: Monad m => (a -> m b) -> m a -> m b

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int
ok :: Either err ()
noop :: Applicative f => f ()

module Fission.Platform.Heroku.Region.Types

-- | Location of Heroku server requesting keys
data Region
California :: Region
Dublin :: Region
Frankfurt :: Region
Oregon :: Region
Singapore :: Region
Sydney :: Region
Tokyo :: Region
Virginia :: Region
instance GHC.Generics.Generic Fission.Platform.Heroku.Region.Types.Region
instance GHC.Classes.Eq Fission.Platform.Heroku.Region.Types.Region
instance GHC.Read.Read Fission.Platform.Heroku.Region.Types.Region
instance GHC.Show.Show Fission.Platform.Heroku.Region.Types.Region
instance Database.Persist.Class.PersistField.PersistField Fission.Platform.Heroku.Region.Types.Region
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Platform.Heroku.Region.Types.Region
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Platform.Heroku.Region.Types.Region
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Platform.Heroku.Region.Types.Region
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Platform.Heroku.Region.Types.Region
instance Data.Swagger.Internal.Schema.ToSchema Fission.Platform.Heroku.Region.Types.Region

module Fission.Platform.Heroku.Password.Types

-- | Heroku add-on password (from <tt>addon-manifest.json</tt>)
newtype Password
Password :: ByteString -> Password
[$sel:getPassword:Password] :: Password -> ByteString
instance Data.String.IsString Fission.Platform.Heroku.Password.Types.Password
instance GHC.Show.Show Fission.Platform.Heroku.Password.Types.Password
instance GHC.Classes.Eq Fission.Platform.Heroku.Password.Types.Password

module Fission.Platform.Heroku.ID.Types

-- | Heroku add-on ID (from <tt>addon-manifest.json</tt>)
newtype ID
ID :: ByteString -> ID
[$sel:getID:ID] :: ID -> ByteString
instance Data.String.IsString Fission.Platform.Heroku.ID.Types.ID
instance GHC.Show.Show Fission.Platform.Heroku.ID.Types.ID
instance GHC.Classes.Eq Fission.Platform.Heroku.ID.Types.ID

module Fission.Platform.Heroku.Auth.Types

-- | An authorized Heroku Platform service
newtype Auth
Auth :: ByteString -> Auth
[$sel:unAuth:Auth] :: Auth -> ByteString
instance GHC.Show.Show Fission.Platform.Heroku.Auth.Types.Auth
instance GHC.Classes.Eq Fission.Platform.Heroku.Auth.Types.Auth

module Fission.Platform.Heroku.Types

module Fission.Platform.Heroku.AddOn.Manifest.Types
data Manifest
Manifest :: Text -> Text -> API -> Manifest
[$sel:id:Manifest] :: Manifest -> Text
[$sel:name:Manifest] :: Manifest -> Text
[$sel:api:Manifest] :: Manifest -> API
($sel:password:API) :: API -> Text
($sel:ssoSalt:API) :: API -> Text
instance GHC.Classes.Eq Fission.Platform.Heroku.AddOn.Manifest.Types.Manifest
instance GHC.Show.Show Fission.Platform.Heroku.AddOn.Manifest.Types.Manifest
instance GHC.Classes.Eq Fission.Platform.Heroku.AddOn.Manifest.Types.API
instance GHC.Show.Show Fission.Platform.Heroku.AddOn.Manifest.Types.API
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Platform.Heroku.AddOn.Manifest.Types.Manifest
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Platform.Heroku.AddOn.Manifest.Types.API

module Fission.Platform.Heroku
host :: String


-- | User payment plans
module Fission.Plan.Types
data Tier
Test :: Tier
Free :: Tier
instance GHC.Generics.Generic Fission.Plan.Types.Tier
instance GHC.Show.Show Fission.Plan.Types.Tier
instance GHC.Classes.Eq Fission.Plan.Types.Tier
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Plan.Types.Tier
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Plan.Types.Tier
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Plan.Types.Tier
instance Data.Swagger.Internal.Schema.ToSchema Fission.Plan.Types.Tier

module Fission.Platform.Heroku.Provision.Request.Types
data Request
Request :: Text -> Text -> Tier -> Region -> UUID -> Request

-- | The URL which should be used to retrieve updated information about the
--   add-on and the app which owns it.
[$sel:callbackUrl:Request] :: Request -> Text

-- | Logical name of the resource being provisioned. , oauthGrant :: Maybe
--   Text -- OAuthGrant -- ^ OAuth object details (nullable).
[$sel:name:Request] :: Request -> Text

-- | Name of the plan to provision (e.g. <tt>basic</tt>).
[$sel:plan:Request] :: Request -> Tier

-- | Physical hosting region of the requesting client.
[$sel:region:Request] :: Request -> Region

-- | The unique identifier Heroku uses for the installed add-on. It
--   corresponds with the id field in the Heroku Platform API.
[$sel:uuid:Request] :: Request -> UUID
instance GHC.Show.Show Fission.Platform.Heroku.Provision.Request.Types.Request
instance GHC.Classes.Eq Fission.Platform.Heroku.Provision.Request.Types.Request
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Platform.Heroku.Provision.Request.Types.Request
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Platform.Heroku.Provision.Request.Types.Request
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Platform.Heroku.Provision.Request.Types.Request
instance Data.Swagger.Internal.Schema.ToSchema Fission.Platform.Heroku.Provision.Request.Types.Request

module Fission.Key.Error
data Error
DoesNotExist :: Error
AlreadyExists :: Error
ParseError :: CryptoError -> Error
instance GHC.Classes.Eq Fission.Key.Error.Error
instance GHC.Exception.Type.Exception Fission.Key.Error.Error
instance GHC.Show.Show Fission.Key.Error.Error


-- | Cryptographic key algorithms
module Fission.Key.Asymmetric.Algorithm.Types

-- | Cryptographic key algorithms (assymmetric)
data Algorithm
RSA2048 :: Algorithm
Ed25519 :: Algorithm
instance GHC.Show.Show Fission.Key.Asymmetric.Algorithm.Types.Algorithm
instance GHC.Classes.Eq Fission.Key.Asymmetric.Algorithm.Types.Algorithm
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Key.Asymmetric.Algorithm.Types.Algorithm
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Key.Asymmetric.Algorithm.Types.Algorithm
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Key.Asymmetric.Algorithm.Types.Algorithm
instance Database.Persist.Class.PersistField.PersistField Fission.Key.Asymmetric.Algorithm.Types.Algorithm
instance Data.Swagger.Internal.Schema.ToSchema Fission.Key.Asymmetric.Algorithm.Types.Algorithm
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Key.Asymmetric.Algorithm.Types.Algorithm

module Fission.Internal.RSA2048.Pair.Types
data Pair
Pair :: PublicKey -> PrivateKey -> Pair
[$sel:pk:Pair] :: Pair -> PublicKey
[$sel:sk:Pair] :: Pair -> PrivateKey
pregenerated :: [Pair]
pk1 :: PublicKey
sk1 :: PrivateKey
pk2 :: PublicKey
sk2 :: PrivateKey
pk3 :: PublicKey
sk3 :: PrivateKey
instance GHC.Show.Show Fission.Internal.RSA2048.Pair.Types.Pair
instance GHC.Classes.Eq Fission.Internal.RSA2048.Pair.Types.Pair
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Internal.RSA2048.Pair.Types.Pair

module Fission.Internal.Orphanage.UUID
instance Database.Persist.Class.PersistField.PersistField Data.UUID.Types.Internal.UUID
instance Database.Persist.Sql.Class.PersistFieldSql Data.UUID.Types.Internal.UUID

module Fission.Internal.Orphanage.Tuple
instance RIO.Prelude.Logger.HasLogFunc (RIO.Prelude.Logger.LogFunc, b)
instance RIO.Prelude.Logger.HasLogFunc (RIO.Prelude.Logger.LogFunc, b, c)

module Fission.Internal.Orphanage.RSA2048.Public
instance RIO.Prelude.Display.Display Crypto.PubKey.RSA.Types.PublicKey
instance Web.Internal.HttpApiData.ToHttpApiData Crypto.PubKey.RSA.Types.PublicKey
instance Web.Internal.HttpApiData.FromHttpApiData Crypto.PubKey.RSA.Types.PublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Crypto.PubKey.RSA.Types.PublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.RSA.Types.PublicKey
instance Database.Persist.Class.PersistField.PersistField Crypto.PubKey.RSA.Types.PublicKey
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Crypto.PubKey.RSA.Types.PublicKey
instance Data.Swagger.Internal.Schema.ToSchema Crypto.PubKey.RSA.Types.PublicKey

module Fission.Internal.Orphanage.RSA2048.Private
instance Test.QuickCheck.Arbitrary.Arbitrary Crypto.PubKey.RSA.Types.PrivateKey

module Fission.Internal.Orphanage.RSA2048
instance Test.QuickCheck.Arbitrary.Arbitrary Crypto.PubKey.Ed25519.SecretKey

module Fission.Internal.Orphanage.PlainText
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText [a]
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText (GHC.Base.NonEmpty a)

module Fission.Internal.Orphanage.Peer
instance Test.QuickCheck.Arbitrary.Arbitrary Network.IPFS.Peer.Types.Peer

module Fission.Internal.Orphanage.OctetStream
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream [a]
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream (GHC.Base.NonEmpty a)

module Fission.Internal.Orphanage.Glob.Pattern
instance Data.Aeson.Types.ToJSON.ToJSON System.FilePath.Glob.Base.Pattern
instance Data.Aeson.Types.FromJSON.FromJSON System.FilePath.Glob.Base.Pattern

module Fission.Internal.Orphanage.Ed25519.SecretKey
instance Test.QuickCheck.Arbitrary.Arbitrary Crypto.PubKey.Ed25519.SecretKey

module Fission.Internal.Orphanage.ClientM
instance Control.Monad.Time.MonadTime Servant.Client.Internal.HttpClient.ClientM

module Fission.Internal.Orphanage.Bytes
instance Database.Persist.Class.PersistField.PersistField Network.IPFS.Bytes.Types.Bytes
instance Database.Persist.Sql.Class.PersistFieldSql Network.IPFS.Bytes.Types.Bytes

module Fission.Internal.Orphanage.ByteString.Lazy
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Internal.ByteString

module Fission.Internal.Orphanage.BasicAuthData
instance Data.Aeson.Types.ToJSON.ToJSON Servant.API.BasicAuth.BasicAuthData
instance Data.Aeson.Types.FromJSON.FromJSON Servant.API.BasicAuth.BasicAuthData
instance Data.Swagger.Internal.Schema.ToSchema Servant.API.BasicAuth.BasicAuthData

module Fission.Internal.Orphanage.BasicAuth
instance Servant.Swagger.Internal.HasSwagger api => Servant.Swagger.Internal.HasSwagger (Servant.API.BasicAuth.BasicAuth x r Servant.API.Sub.:> api)

module Fission.Internal.Orphanage.BaseUrl
instance Test.QuickCheck.Arbitrary.Arbitrary Servant.Client.Core.BaseUrl.BaseUrl
instance Data.Swagger.Internal.Schema.ToSchema Servant.Client.Core.BaseUrl.BaseUrl

module Fission.Internal.Mock.Session.Types

-- | The result of running a mocked test session
data Session effs a
Session :: [OpenUnion effs] -> a -> Session effs a

-- | List of effects that were run
[$sel:effectLog:Session] :: Session effs a -> [OpenUnion effs]

-- | Pure return value
[$sel:result:Session] :: Session effs a -> a

module Fission.Internal.Meta.Package.Types
data Package
Package :: !Maybe Text -> !Maybe Text -> Package
[$sel:name:Package] :: Package -> !Maybe Text
[$sel:version:Package] :: Package -> !Maybe Text
instance GHC.Classes.Eq Fission.Internal.Meta.Package.Types.Package
instance GHC.Show.Show Fission.Internal.Meta.Package.Types.Package
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Internal.Meta.Package.Types.Package

module Fission.Internal.Meta.Package
package :: Maybe Package
fromContents :: ByteString -> Maybe Package

module Fission.Internal.Meta

module Fission.Internal.MIME
mimeExt :: Map MimeType Extension
lookupExt :: MimeType -> Extension
defaultMimeLookup :: FileName -> MimeType

module Fission.Internal.Fixture.Web
fissionURL :: BaseUrl
failureResp :: Status -> ClientError
failure502 :: ClientError
failure504 :: ClientError

module Fission.Internal.CLI.Meta
data Package
Package :: !Maybe Text -> !Maybe Text -> Package
[$sel:name:Package] :: Package -> !Maybe Text
[$sel:version:Package] :: Package -> !Maybe Text
fromContents :: ByteString -> Maybe Package
package :: Maybe Package

module Fission.Internal.Bool
anyX :: [a -> Bool] -> a -> Bool

-- | Test if any string-like item is truthy.
--   
--   <pre>
--   &gt;&gt;&gt; truthy "t"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truthy "f"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truthy "on"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; truthy "no"
--   False
--   </pre>
truthy :: (Eq a, IsString a) => a -> Bool

module Fission.Internal.URL

-- | Check that a byte represents a valid URL character.
--   
--   $setup &gt;&gt;&gt; import Data.Char (ord) &gt;&gt;&gt; fromChar = ord
--   .&gt; fromIntegral
--   
--   <pre>
--   &gt;&gt;&gt; isURLCharacter (fromChar 'a')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isURLCharacter (fromChar '/')
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isURLCharacter (fromChar '?')
--   False
--   </pre>
isURLCharacter :: Word8 -> Bool


-- | "Scrubbed bytes" don't show up in the console
module Fission.Internal.Base64.Scrubbed
scrub :: ByteString -> ScrubbedBytes

-- | Scrub incoming base64-encoded bytes
scrubB64 :: ByteString -> ScrubbedBytes

module Fission.Internal.Crypto
base64ToEd25519Signature :: ByteString -> CryptoFailable Signature
base64ToEd25519PK :: ByteString -> CryptoFailable PublicKey

module Fission.Internal.Base64
toB64ByteString :: ByteArrayAccess a => a -> ByteString
toByteString :: ByteArrayAccess a => a -> ByteString

module Fission.Key.Store
create :: MonadIO m => m (Either Error ())
forceCreate :: MonadIO m => m ()
delete :: MonadIO m => m ()
sign :: MonadIO m => ByteString -> m (Either Error Signature)
signWith :: SecretKey -> ByteString -> Signature
publicKeyX :: MonadIO m => m (Either Error PublicKey)
publicKeyEd :: MonadIO m => m (Either Error PublicKey)
readX :: MonadIO m => m (Either Error SecretKey)
readEd :: MonadIO m => m (Either Error SecretKey)
exists :: MonadIO m => m Bool
location :: MonadIO m => m FilePath

module Fission.Internal.Orphanage.Ed25519.PublicKey
instance RIO.Prelude.Display.Display Crypto.PubKey.Ed25519.PublicKey
instance Web.Internal.HttpApiData.ToHttpApiData Crypto.PubKey.Ed25519.PublicKey
instance Web.Internal.HttpApiData.FromHttpApiData Crypto.PubKey.Ed25519.PublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Crypto.PubKey.Ed25519.PublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.Ed25519.PublicKey
instance Test.QuickCheck.Arbitrary.Arbitrary Crypto.PubKey.Ed25519.PublicKey

module Fission.Key.Asymmetric.Public.Types
data Public
Ed25519PublicKey :: PublicKey -> Public
RSAPublicKey :: PublicKey -> Public
instance GHC.Classes.Eq Fission.Key.Asymmetric.Public.Types.Public
instance GHC.Show.Show Fission.Key.Asymmetric.Public.Types.Public
instance RIO.Prelude.Display.Display Fission.Key.Asymmetric.Public.Types.Public
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Key.Asymmetric.Public.Types.Public
instance Web.Internal.HttpApiData.ToHttpApiData Fission.Key.Asymmetric.Public.Types.Public
instance Web.Internal.HttpApiData.FromHttpApiData Fission.Key.Asymmetric.Public.Types.Public
instance Data.String.IsString (Data.Either.Either Data.Text.Internal.Text Fission.Key.Asymmetric.Public.Types.Public)
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Key.Asymmetric.Public.Types.Public
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Key.Asymmetric.Public.Types.Public
instance Database.Persist.Class.PersistField.PersistField Fission.Key.Asymmetric.Public.Types.Public
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Key.Asymmetric.Public.Types.Public
instance Data.Swagger.Internal.Schema.ToSchema Fission.Key.Asymmetric.Public.Types.Public


-- | Top-level assymmetric-key module
module Fission.Key.Asymmetric


-- | Top-level key cryptography module
module Fission.Key

module Fission.Internal.Fixture.Key.Ed25519
pk :: Public
rawPK :: Text


-- | Helpers for working with Base64URL-encoded strings
module Fission.Internal.Base64.URL

-- | Go from Base64URL to Base64
decode :: Text -> Text

-- | Go from Base64 to Base64URL
encode :: Text -> Text
encodeBS :: ByteString -> ByteString
encodeJWT :: (ToJSON a, ToJSON b) => a -> b -> Text
encodeJWTPart :: ToJSON a => a -> ByteString
addPadding :: ByteString -> ByteString

module Fission.Internal.Orphanage.Ed25519.Signature
instance RIO.Prelude.Display.Display Crypto.PubKey.Ed25519.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.Ed25519.Signature
instance Data.Aeson.Types.FromJSON.FromJSON Crypto.PubKey.Ed25519.Signature

module Fission.IPFS.Linked.Class

-- | A monad representing when you have a two-way dependent external IPFS
--   node
class Monad m => MonadLinkedIPFS m
getLinkedPeers :: MonadLinkedIPFS m => m (NonEmpty Peer)

module Fission.IPFS.Linked


-- | Environment variables
module Fission.Environment

-- | Switch on an environment flag
--   
--   <pre>
--   &gt;&gt;&gt; withFlag "DEBUG" "nope" "yep"
--   "nope"
--   </pre>
withFlag :: String -> a -> a -> IO a

-- | Perform actions on an environment variable, with fallback if not
--   available
--   
--   <pre>
--   &gt;&gt;&gt; withEnv "HOST" "my.host" (drop 1)
--   "my.host"
--   </pre>
withEnv :: String -> a -> (String -> a) -> IO a

-- | Check if an environment flag is set to <a>True</a> (case-insensitive)
--   
--   <pre>
--   &gt;&gt;&gt; getFlag "THIS_KEY_IS_UNSET"
--   Nothing
--   </pre>
getFlag :: String -> IO (Maybe Bool)

-- | Get an environment variable. <a>error</a>s if not found.
getEnv :: FromEnv a => IO a

-- | Get a given flag, default to the given value if not found
getFlagWithDefault :: String -> Bool -> IO Bool

-- | Fallback value for a monadic lookup
--   
--   <pre>
--   &gt;&gt;&gt; Right (Just 9) .!~ 42
--   Right 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right Nothing .!~ 42
--   Right 42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left (Just 9) .!~ 42
--   Left (Just 9)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left Nothing .!~ 42
--   Left Nothing
--   </pre>
(.!~) :: Monad m => m (Maybe a) -> a -> m a


-- | Helpers for running the Fission applications
module Fission.Internal.App

-- | Run the given simple app. Set <tt>DEBUG</tt> to <a>True</a> to enable
--   verbose app logging
runApp :: RIO SimpleApp a -> IO a

-- | Check if <tt>DEBUG</tt> is set to <a>True</a>
isDebugEnabled :: IO Bool

-- | Sets the env variable <tt>RIO_VERBOSE</tt> to the given value Note:
--   unsetting <tt>RIO_VERBOSE</tt> is the only way for it to be
--   interpretted as False
setRioVerbose :: Bool -> IO ()

module Fission.Email.SendInBlue.TemplateId.Types
newtype TemplateId
TemplateId :: Int64 -> TemplateId
[$sel:unTemplateId:TemplateId] :: TemplateId -> Int64
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Email.SendInBlue.TemplateId.Types.TemplateId
instance GHC.Show.Show Fission.Email.SendInBlue.TemplateId.Types.TemplateId
instance GHC.Classes.Eq Fission.Email.SendInBlue.TemplateId.Types.TemplateId

module Fission.Email.SendInBlue.Response.Types
newtype Response
Response :: Text -> Response
[$sel:messageId:Response] :: Response -> Text
instance RIO.Prelude.Display.Display Fission.Email.SendInBlue.Response.Types.Response
instance Data.String.IsString Fission.Email.SendInBlue.Response.Types.Response
instance GHC.Show.Show Fission.Email.SendInBlue.Response.Types.Response
instance GHC.Classes.Eq Fission.Email.SendInBlue.Response.Types.Response
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Email.SendInBlue.Response.Types.Response

module Fission.Email.SendInBlue.ApiKey.Types
newtype ApiKey
ApiKey :: Text -> ApiKey
[$sel:unApiKey:ApiKey] :: ApiKey -> Text
instance Data.String.IsString Fission.Email.SendInBlue.ApiKey.Types.ApiKey
instance GHC.Show.Show Fission.Email.SendInBlue.ApiKey.Types.ApiKey
instance GHC.Classes.Eq Fission.Email.SendInBlue.ApiKey.Types.ApiKey
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Email.SendInBlue.ApiKey.Types.ApiKey

module Fission.DNS
splitRecord :: Text -> NonEmpty Text

module Fission.Challenge.Types
newtype Challenge
Challenge :: Text -> Challenge
[$sel:unChallenge:Challenge] :: Challenge -> Text
instance Web.Internal.HttpApiData.ToHttpApiData Fission.Challenge.Types.Challenge
instance Data.String.IsString Fission.Challenge.Types.Challenge
instance GHC.Show.Show Fission.Challenge.Types.Challenge
instance GHC.Classes.Eq Fission.Challenge.Types.Challenge
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Challenge.Types.Challenge
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Challenge.Types.Challenge
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Challenge.Types.Challenge
instance Web.Internal.HttpApiData.FromHttpApiData Fission.Challenge.Types.Challenge
instance Database.Persist.Class.PersistField.PersistField Fission.Challenge.Types.Challenge
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Challenge.Types.Challenge
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Fission.Challenge.Types.Challenge
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText Fission.Challenge.Types.Challenge
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Fission.Challenge.Types.Challenge
instance Data.Swagger.Internal.Schema.ToSchema Fission.Challenge.Types.Challenge

module Fission.CLI.Prompt.Error.Types
data Err
RequiredField :: Err
instance GHC.Exception.Type.Exception Fission.CLI.Prompt.Error.Types.Err
instance GHC.Show.Show Fission.CLI.Prompt.Error.Types.Err

module Fission.CLI.Prompt

-- | Continues prompting the user until they put in a valid response
reask :: (MonadIO m, MonadLogger m) => Text -> (ByteString -> Bool) -> m ByteString

-- | reask where valid responses are at least 1 character long
reaskNotEmpty :: (MonadIO m, MonadLogger m) => Text -> m ByteString

-- | reask where valid responses are at least 1 character long
reaskNotEmpty' :: (MonadIO m, MonadLogger m) => Text -> m Text

-- | reask where valid responses are some form of yes/no
reaskYN :: (MonadIO m, MonadLogger m) => Text -> m Bool
reaskWithError :: (MonadIO m, MonadLogger m) => Text -> (ByteString -> Bool) -> m () -> m ByteString

module Fission.CLI.IPFS.Error.Types
data Err
UnableToConnect :: Err
instance GHC.Exception.Type.Exception Fission.CLI.IPFS.Error.Types.Err
instance GHC.Show.Show Fission.CLI.IPFS.Error.Types.Err

module Fission.CLI.Environment.Error
data Env
EnvNotFound :: Env
EnvIncomplete :: Env
instance GHC.Generics.Generic Fission.CLI.Environment.Error.Env
instance GHC.Classes.Eq Fission.CLI.Environment.Error.Env
instance GHC.Exception.Type.Exception Fission.CLI.Environment.Error.Env
instance GHC.Show.Show Fission.CLI.Environment.Error.Env

module Fission.CLI.Environment.Class

-- | A monad representing access to a Fission server
class Monad m => MonadEnvironment m
getIgnoredFiles :: MonadEnvironment m => m Ignored
instance Fission.CLI.Environment.Class.MonadEnvironment m => Fission.CLI.Environment.Class.MonadEnvironment (Control.Monad.Trans.Except.ExceptT GHC.Exception.Type.SomeException m)


-- | Visual flourishes for indicating a loading state
module Fission.CLI.Display.Loader

-- | Perform actions in the background while displaying a loading indicator
--   
--   The indicator disappears when the process completes
withLoader :: MonadUnliftIO m => Natural -> m a -> m a

-- | Reset the cursor position back one priontable character, and clear the
--   *entire* line
reset :: MonadIO m => m ()

-- | Prepare for the next step -- in this case wait and reset the line
prep :: MonadIO m => Natural -> m ()

-- | Loading animation
loading :: MonadIO m => Natural -> m ()


-- | Wait for an action on the CLI
module Fission.CLI.Display.Wait
waitFor :: MonadUnliftIO m => ByteString -> m a -> m a


-- | Helpers for working with a cursor in a console
module Fission.CLI.Display.Cursor

-- | Perform console actions without a cursor visible
withHidden :: MonadUnliftIO m => m a -> m a

module Fission.CLI.Config.Connected.Error.Types
data Error
NoKeyFile :: Error
NotRegistered :: Error
CannotConnect :: Error
PeersNotFound :: Error
NoApp :: Error
instance GHC.Exception.Type.Exception Fission.CLI.Config.Connected.Error.Types.Error
instance GHC.Show.Show Fission.CLI.Config.Connected.Error.Types.Error
instance GHC.Classes.Eq Fission.CLI.Config.Connected.Error.Types.Error

module Fission.CLI.Command.Watch.Types

-- | Arguments, flags &amp; switches for the <tt>watch</tt> command
data Options
Options :: Bool -> FilePath -> Options
[$sel:dnsOnly:Options] :: Options -> Bool
[$sel:path:Options] :: Options -> FilePath

module Fission.CLI.Command.Up.Types

-- | Arguments, flags &amp; switches for the <tt>up</tt> command
data Options
Options :: Bool -> FilePath -> Options
[$sel:dnsOnly:Options] :: Options -> Bool
[$sel:path:Options] :: Options -> FilePath
instance GHC.Classes.Eq Fission.CLI.Command.Up.Types.Options
instance GHC.Show.Show Fission.CLI.Command.Up.Types.Options

module Fission.CLI.Command.Types
data Command m input output
Command :: !Text -> !Text -> !Parser input -> !input -> m output -> Command m input output
[$sel:command:Command] :: Command m input output -> !Text
[$sel:description:Command] :: Command m input output -> !Text
[$sel:argParser:Command] :: Command m input output -> !Parser input
[$sel:handler:Command] :: Command m input output -> !input -> m output
type Leaf = ExceptT (IO ()) (Writer (Mod CommandFields (IO ()))) ()

module Fission.CLI.Command.App.Init.Types

-- | Arguments, flags &amp; switches for the `app init` command
data Options
Options :: !FilePath -> !Maybe FilePath -> Options
[$sel:appDir:Options] :: Options -> !FilePath
[$sel:buildDir:Options] :: Options -> !Maybe FilePath
newtype OptionalFilePath
OptionalFilePath :: Maybe FilePath -> OptionalFilePath
instance Data.String.IsString Fission.CLI.Command.App.Init.Types.OptionalFilePath

module Fission.CLI.Command
runWith :: (m () -> IO ()) -> Command m input () -> Leaf

module Fission.Authorization.Potency.Types

-- | How much power allowed in an authorization
data Potency

-- | Read signature only -- just a proof. Cannot delegate further.
AuthNOnly :: Potency

-- | Append new files
AppendOnly :: Potency

-- | Overwrite / destroy. "Ownership is the right to destroy"
Destructive :: Potency

-- | i.e. SuperUser -- Financial, major account settings, &amp;c
SuperUser :: Potency
instance GHC.Classes.Ord Fission.Authorization.Potency.Types.Potency
instance GHC.Classes.Eq Fission.Authorization.Potency.Types.Potency
instance GHC.Show.Show Fission.Authorization.Potency.Types.Potency
instance RIO.Prelude.Display.Display Fission.Authorization.Potency.Types.Potency
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Authorization.Potency.Types.Potency
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Authorization.Potency.Types.Potency
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Authorization.Potency.Types.Potency

module Fission.App.Content.Initializer.Class
class Monad m => Initializer m

-- | Placeholder app content (e.g. splash page)
placeholder :: Initializer m => m CID
instance Fission.App.Content.Initializer.Class.Initializer m => Fission.App.Content.Initializer.Class.Initializer (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Content.Initializer

module Fission.App.Content
empty :: CID

module Fission.AWS.Zone.Types

-- | Type safety wrapper for a Route53 zone ID
newtype ZoneID
ZoneID :: Text -> ZoneID
[$sel:getZoneID:ZoneID] :: ZoneID -> Text
instance GHC.Show.Show Fission.AWS.Zone.Types.ZoneID
instance GHC.Classes.Eq Fission.AWS.Zone.Types.ZoneID
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.AWS.Zone.Types.ZoneID
instance RIO.Prelude.Display.Display Fission.AWS.Zone.Types.ZoneID
instance Database.Persist.Class.PersistField.PersistField Fission.AWS.Zone.Types.ZoneID
instance Database.Persist.Sql.Class.PersistFieldSql Fission.AWS.Zone.Types.ZoneID
instance Data.Swagger.Internal.Schema.ToSchema Fission.AWS.Zone.Types.ZoneID
instance Data.Aeson.Types.FromJSON.FromJSON Fission.AWS.Zone.Types.ZoneID


-- | Fission-specific AWS types
module Fission.AWS.Types

-- | Type safety wrapper for a Route53 zone ID
newtype ZoneID
ZoneID :: Text -> ZoneID
[$sel:getZoneID:ZoneID] :: ZoneID -> Text
newtype MockRoute53
MockRoute53 :: Bool -> MockRoute53
instance GHC.Classes.Eq Fission.AWS.Types.MockRoute53
instance GHC.Show.Show Fission.AWS.Types.MockRoute53
instance Data.Aeson.Types.FromJSON.FromJSON Fission.AWS.Types.MockRoute53


-- | Random values
module Fission.Random

-- | Generate random alphanumeric <tt>Text</tt> with a given length
alphaNum :: MonadIO m => Natural -> m Text

-- | Generate random alphanumeric symbol <tt>Text</tt> with a given length
alphaNumSymbol :: MonadIO m => Natural -> m Text

-- | Generate random <a>ByteString</a> with a given length
bsRandomLength :: MonadIO m => Natural -> m ByteString


-- | Application security
module Fission.Security.Types

-- | An application secret
newtype Secret
Secret :: Text -> Secret
[$sel:unSecret:Secret] :: Secret -> Text

-- | A text digest
type SecretDigest = Text
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Security.Types.Secret
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Security.Types.Secret
instance GHC.Generics.Generic Fission.Security.Types.Secret
instance GHC.Show.Show Fission.Security.Types.Secret
instance GHC.Classes.Eq Fission.Security.Types.Secret
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Security.Types.Secret
instance Data.Swagger.Internal.Schema.ToSchema Fission.Security.Types.Secret


-- | Application security
module Fission.Security
mkSecret :: Natural -> IO (Either UnicodeException Secret)
toSecret :: ByteString -> Either UnicodeException Secret

-- | Create a digest
class Digestable a
digest :: Digestable a => a -> SecretDigest
instance Fission.Security.Digestable Data.ByteString.Internal.ByteString
instance Fission.Security.Digestable Data.Text.Internal.Text

module Fission.SemVer.Types

-- | Semver broken out by part
data SemVer
SemVer :: !Word8 -> !Word8 -> !Word8 -> SemVer
[$sel:major:SemVer] :: SemVer -> !Word8
[$sel:minor:SemVer] :: SemVer -> !Word8
[$sel:patch:SemVer] :: SemVer -> !Word8
instance GHC.Classes.Eq Fission.SemVer.Types.SemVer
instance GHC.Show.Show Fission.SemVer.Types.SemVer
instance RIO.Prelude.Display.Display Fission.SemVer.Types.SemVer
instance GHC.Classes.Ord Fission.SemVer.Types.SemVer
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.SemVer.Types.SemVer
instance Data.Aeson.Types.ToJSON.ToJSON Fission.SemVer.Types.SemVer
instance Data.Aeson.Types.FromJSON.FromJSON Fission.SemVer.Types.SemVer

module Fission.SemVer

module Fission.Time

-- | The Doherty theshold in seconds
doherty :: NominalDiffTime

-- | The Doherty threshold in Âµs
dohertyMicroSeconds :: Int

module Fission.URL.DomainName.Types

-- | Type safety wrapper for domain names
newtype DomainName
DomainName :: Text -> DomainName
[$sel:get:DomainName] :: DomainName -> Text
instance Web.PathPieces.PathPiece Fission.URL.DomainName.Types.DomainName
instance Data.String.IsString Fission.URL.DomainName.Types.DomainName
instance GHC.Classes.Ord Fission.URL.DomainName.Types.DomainName
instance GHC.Read.Read Fission.URL.DomainName.Types.DomainName
instance GHC.Show.Show Fission.URL.DomainName.Types.DomainName
instance GHC.Generics.Generic Fission.URL.DomainName.Types.DomainName
instance GHC.Classes.Eq Fission.URL.DomainName.Types.DomainName
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.URL.DomainName.Types.DomainName
instance RIO.Prelude.Display.Display Fission.URL.DomainName.Types.DomainName
instance Database.Persist.Class.PersistField.PersistField Fission.URL.DomainName.Types.DomainName
instance Database.Persist.Sql.Class.PersistFieldSql Fission.URL.DomainName.Types.DomainName
instance Data.Swagger.Internal.Schema.ToSchema Fission.URL.DomainName.Types.DomainName
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Fission.URL.DomainName.Types.DomainName
instance Web.Internal.HttpApiData.ToHttpApiData Fission.URL.DomainName.Types.DomainName
instance Web.Internal.HttpApiData.FromHttpApiData Fission.URL.DomainName.Types.DomainName
instance Data.Aeson.Types.ToJSON.ToJSON Fission.URL.DomainName.Types.DomainName
instance Data.Aeson.Types.FromJSON.FromJSON Fission.URL.DomainName.Types.DomainName
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Fission.URL.DomainName.Types.DomainName
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream Fission.URL.DomainName.Types.DomainName
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText Fission.URL.DomainName.Types.DomainName

module Fission.URL.DomainName

module Fission.App.Domain.Initializer.Class
class Monad m => Initializer m

-- | The default domain that's managed by Fission
initial :: Initializer m => m DomainName
instance Fission.App.Domain.Initializer.Class.Initializer m => Fission.App.Domain.Initializer.Class.Initializer (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Domain.Initializer

module Fission.URL.Path.Types
data Path a
WithPath :: a -> [Text] -> Path a
instance GHC.Show.Show a => GHC.Show.Show (Fission.URL.Path.Types.Path a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Fission.URL.Path.Types.Path a)
instance RIO.Prelude.Display.Display a => RIO.Prelude.Display.Display (Fission.URL.Path.Types.Path a)

module Fission.URL.Subdomain.Types

-- | Type safety wrapper for subdomains
newtype Subdomain
Subdomain :: Text -> Subdomain
[$sel:get:Subdomain] :: Subdomain -> Text
instance Data.String.IsString Fission.URL.Subdomain.Types.Subdomain
instance GHC.Show.Show Fission.URL.Subdomain.Types.Subdomain
instance GHC.Classes.Eq Fission.URL.Subdomain.Types.Subdomain
instance RIO.Prelude.Display.Display Fission.URL.Subdomain.Types.Subdomain
instance GHC.Base.Semigroup Fission.URL.Subdomain.Types.Subdomain
instance Data.Aeson.Types.ToJSON.ToJSON Fission.URL.Subdomain.Types.Subdomain
instance Database.Persist.Class.PersistField.PersistField Fission.URL.Subdomain.Types.Subdomain
instance Database.Persist.Sql.Class.PersistFieldSql Fission.URL.Subdomain.Types.Subdomain
instance Data.Swagger.Internal.Schema.ToSchema Fission.URL.Subdomain.Types.Subdomain
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Fission.URL.Subdomain.Types.Subdomain
instance Web.Internal.HttpApiData.FromHttpApiData Fission.URL.Subdomain.Types.Subdomain
instance Data.Aeson.Types.FromJSON.FromJSON Fission.URL.Subdomain.Types.Subdomain
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Fission.URL.Subdomain.Types.Subdomain
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream Fission.URL.Subdomain.Types.Subdomain
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText Fission.URL.Subdomain.Types.Subdomain
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.URL.Subdomain.Types.Subdomain


-- | Subdomain helpers
module Fission.URL.Subdomain

module Fission.URL.Types
data URL
URL :: DomainName -> Maybe Subdomain -> URL
[$sel:domainName:URL] :: URL -> DomainName
[$sel:subdomain:URL] :: URL -> Maybe Subdomain
instance GHC.Classes.Eq Fission.URL.Types.URL
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.URL.Types.URL
instance RIO.Prelude.Display.Display Fission.URL.Types.URL
instance GHC.Show.Show Fission.URL.Types.URL
instance Web.Internal.HttpApiData.ToHttpApiData Fission.URL.Types.URL
instance Web.Internal.HttpApiData.FromHttpApiData Fission.URL.Types.URL
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Fission.URL.Types.URL
instance Data.Swagger.Internal.Schema.ToSchema Fission.URL.Types.URL
instance Data.Aeson.Types.ToJSON.ToJSON Fission.URL.Types.URL
instance Data.Aeson.Types.FromJSON.FromJSON Fission.URL.Types.URL

module Fission.App.URL.Class

-- | Interface for getting the base app URL
class Monad m => HasAppURL m

-- | Get the base app URL (at time of writing: 'fission.app')
getAppURL :: HasAppURL m => m URL

module Fission.User.DID.Method.Types
data Method
Key :: Method
instance GHC.Classes.Eq Fission.User.DID.Method.Types.Method
instance GHC.Show.Show Fission.User.DID.Method.Types.Method
instance RIO.Prelude.Display.Display Fission.User.DID.Method.Types.Method
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.User.DID.Method.Types.Method
instance Data.Aeson.Types.ToJSON.ToJSON Fission.User.DID.Method.Types.Method
instance Data.Aeson.Types.FromJSON.FromJSON Fission.User.DID.Method.Types.Method

module Fission.User.DID.Types

-- | A DID key, broken into its constituant parts
--   
--   Format: did:key:<a>MULTICODEC(public-key-type,
--   raw-public-key-bytes))</a>
--   
--   <pre>
--   NOTE: Multibase-prefixes are encoding agnostic. "z" is "z",
--   not 0x7a ("z" encoded as ASCII/UTF-8).
--   For example, in UTF-32, "z" would be [0x7a, 0x00, 0x00, 0x00].
--   
--   Expressing a base58btc encoded ed25519 cryptographic identifier would look like this:
--   0x7a 0xed01 ED25519_PUBLIC_KEY_BYTES
--   [...]
--   Expressing a cryptographic identifier that is a base58btc encoded RSA SPKI-based
--     public key fingerprint using SHA2-256/256 would look like this:
--   0x7a 0x5d 0x12 0x20 HASH_BYTES
--   </pre>
--   
--   <a>https://github.com/w3c-ccg/lds-ed25519-2018/issues/3</a>
--   
--   <pre>
--   So the procedure to express other types of keys is:
--   
--      1. Find the multicodec representation for your key type.
--           For example, the registration for secp256k1 keys is pending
--           over at multiformats/multicodec#160.
--      2. Encode the raw public key bytes using that multicodec value.
--      3. Pick a character encoding (I suggest base58-btc),
--           and convert it to a character string using Multibase.
--      4. Prepend did:key: to that string, and there you have it!
--   </pre>
--   
--   
--   <a>https://github.com/w3c-ccg/did-method-key/issues/3#issuecomment-594190524</a>
--   
--   NOTE: The multihash is in a middle-endian format -- SB base-128 with
--   continuation flags More here:
--   <a>https://github.com/multiformats/unsigned-varint</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   Ed25519
--   
--   <pre>
--   &gt;&gt;&gt; eitherDecode "\"did:key:zStEZpzSMtTt9k2vszgvCwF4fLQQSyA15W5AQ4z3AR6Bx4eFJ5crJFbuGxKmbma4\"" :: Either String DID
--   Right (DID {method = Key, publicKey = Hv+AVRD2WUjUFOsSNbsmrp9fokuwrUnjBcr92f0kxw4=})
--   </pre>
--   
--   RSA
--   
--   eitherDecode
--   ""did:key:z1LBnwEktwYLrpPhuwFowdVwAFX5zpRo9rrVzwiRRBBiaBoCR7hNqgstW7VM3T9auNbqTmQW4vdHb61RhTMVgCp1BTxuaKU3anWoERFXpuZvfE39g8u7HS9BeD1QJN1fX6S8vvskaPhxFkwLtGr4ZffkUE57WZpNWM6U6BqdktZxmKzxC85zN4FC9Ws5LHuGfxaCuBLiUfA7qEYVSz1Qu1rZDpD6NyfUNrHJ1ErZduJun976nbFHrmDnU47RcSMFESbNKDi1467tRfubsMrDzebdCFKQ2m1AYysto2i6Wmcnucjt3tnwTqe7Bo8L1g8h8UGA946DF3WeGbPUGqznsUdLq6XLCmJzJkJmrNyeZkswdyPX2Vu6J9E4J12Sb3h9ds7atByamftitEZsf6hPJkLUXGThYpCnmRAArRRfPY2H6cKDc7AcnFPyNHGkab5ZFo4qvgBZytbK1K5oD3HfQ6E2ybLhyC2b8i5wo6DLtm9ufixSJNNTH7Uikk88CmertKR7s12CK1WLEM3Zu5YBZNphnjj7cp8QTodAehRPV9NG1CLEAMJVN79DvYe6SfiafJobcvfD8npfS6jcejcyouQbEpKDG7QAnKS48P4AvgBqDvfNUe54jMkk6r6CoX4LcYGHukZDEnea9kwkEoXkUYS4j1AfbKh44FzSuXbQqZnjjVpThxCNmmNn1E4qHmsFkvGoF3FN55CPkoGfDCvyQJgqmsFmpeTJSy9wzv4MvbqpuATxr7eyxsGeCWQkcDwub32inGpR3reTfzRJECCFZarnXdcC5Pidakb1Wu8L""
--   Right (DID {method = Key, publicKey =
--   MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnzyis1ZjfNB0bBgKFMSvvkTtwlvBsaJq7S5wA+kzeVOVpVWwkWdVha4s38XM<i>pa</i>yr47av7+z3VTmvDRyAHcaT92whREFpLv9cj5lTeJSibyr<i>Mrm</i>YtjCZVWgaOYIhwrXwKLqPr<i>11inWsAkfIytvHWTxZYEcXLgAXFuUuaS3uF9gEiNQwzGTU1v0FqkqTBr4B8nW3HCN47XUu0t8Y0e+lf4s4OxQawWD79J9</i>5d3Ry0vbV3Am1FtGJiJvOwRsIfVChDpYStTcHTCMqtvWbV6L11BWkpzGXSW4Hv43qa+GSYOD2QU68Mb59oSk2OB+BtOLpJofmbGEGgvmwyCI9MwIDAQAB})
data DID
DID :: !Method -> !Public -> DID
[$sel:method:DID] :: DID -> !Method
[$sel:publicKey:DID] :: DID -> !Public
instance GHC.Classes.Eq Fission.User.DID.Types.DID
instance GHC.Show.Show Fission.User.DID.Types.DID
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.User.DID.Types.DID
instance RIO.Prelude.Display.Display Fission.User.DID.Types.DID
instance Data.Aeson.Types.ToJSON.ToJSON Fission.User.DID.Types.DID
instance Data.Aeson.Types.FromJSON.FromJSON Fission.User.DID.Types.DID

module Fission.User.DID

module Fission.CLI.Environment.Types

-- | Virtual environment built up from many layers of <a>Override</a>.
data Environment
Environment :: ![Peer] -> !Ignored -> !Maybe URL -> !Maybe FilePath -> !Maybe DID -> Environment
[$sel:peers:Environment] :: Environment -> ![Peer]
[$sel:ignored:Environment] :: Environment -> !Ignored
[$sel:appURL:Environment] :: Environment -> !Maybe URL
[$sel:buildDir:Environment] :: Environment -> !Maybe FilePath
[$sel:serverDID:Environment] :: Environment -> !Maybe DID
instance Data.Aeson.Types.ToJSON.ToJSON Fission.CLI.Environment.Types.Environment
instance Data.Aeson.Types.FromJSON.FromJSON Fission.CLI.Environment.Types.Environment

module Fission.Authorization.ServerDID.Class
class Monad m => ServerDID m
getServerDID :: ServerDID m => m DID
class Monad m => PublicizeServerDID m
publicize :: PublicizeServerDID m => m (Either ServerError ())

module Fission.Authorization.ServerDID

module Fission.User.Email.Types
newtype Email
Email :: Text -> Email
[$sel:unEmail:Email] :: Email -> Text
instance Web.Internal.HttpApiData.ToHttpApiData Fission.User.Email.Types.Email
instance Data.String.IsString Fission.User.Email.Types.Email
instance GHC.Show.Show Fission.User.Email.Types.Email
instance GHC.Classes.Eq Fission.User.Email.Types.Email
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Fission.User.Email.Types.Email
instance Data.Swagger.Internal.Schema.ToSchema Fission.User.Email.Types.Email
instance GHC.Generics.Generic Fission.User.Email.Types.Email
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.User.Email.Types.Email
instance Data.Aeson.Types.ToJSON.ToJSON Fission.User.Email.Types.Email
instance Data.Aeson.Types.FromJSON.FromJSON Fission.User.Email.Types.Email
instance Web.Internal.HttpApiData.FromHttpApiData Fission.User.Email.Types.Email
instance Database.Persist.Class.PersistField.PersistField Fission.User.Email.Types.Email
instance Database.Persist.Sql.Class.PersistFieldSql Fission.User.Email.Types.Email
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Fission.User.Email.Types.Email
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText Fission.User.Email.Types.Email

module Fission.User.Password.Types
newtype Password
Password :: Text -> Password
[$sel:password:Password] :: Password -> Text
instance Data.Swagger.Internal.Schema.ToSchema Fission.User.Password.Types.Password
instance GHC.Show.Show Fission.User.Password.Types.Password
instance GHC.Generics.Generic Fission.User.Password.Types.Password
instance GHC.Classes.Eq Fission.User.Password.Types.Password
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.User.Password.Types.Password
instance Data.Aeson.Types.ToJSON.ToJSON Fission.User.Password.Types.Password
instance Data.Aeson.Types.FromJSON.FromJSON Fission.User.Password.Types.Password

module Fission.User.Role.Types
data Role
Regular :: Role
Admin :: Role
instance Database.Persist.Class.PersistField.PersistField Fission.User.Role.Types.Role
instance Database.Persist.Sql.Class.PersistFieldSql Fission.User.Role.Types.Role
instance GHC.Classes.Eq Fission.User.Role.Types.Role
instance GHC.Read.Read Fission.User.Role.Types.Role
instance GHC.Show.Show Fission.User.Role.Types.Role

module Fission.User.Security

-- | Create a <a>SecretDigest</a> from some data, such as a users ID Barely
--   an obsfucating technique, but enough to hide DB ordering
hashID :: Digestable a => a -> SecretDigest

-- | Generate an ID
genID :: MonadIO m => m SecretDigest

module Fission.User.Username.Types
newtype Username
Username :: Text -> Username
[$sel:username:Username] :: Username -> Text
instance Data.String.IsString Fission.User.Username.Types.Username
instance RIO.Prelude.Display.Display Fission.User.Username.Types.Username
instance GHC.Classes.Eq Fission.User.Username.Types.Username
instance GHC.Show.Show Fission.User.Username.Types.Username
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.User.Username.Types.Username
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Fission.User.Username.Types.Username
instance Web.Internal.HttpApiData.ToHttpApiData Fission.User.Username.Types.Username
instance Database.Persist.Class.PersistField.PersistField Fission.User.Username.Types.Username
instance Database.Persist.Sql.Class.PersistFieldSql Fission.User.Username.Types.Username
instance Data.Aeson.Types.ToJSON.ToJSON Fission.User.Username.Types.Username
instance Data.Aeson.Types.FromJSON.FromJSON Fission.User.Username.Types.Username
instance Web.Internal.HttpApiData.FromHttpApiData Fission.User.Username.Types.Username
instance Data.Swagger.Internal.Schema.ToSchema Fission.User.Username.Types.Username
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Fission.User.Username.Types.Username
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText Fission.User.Username.Types.Username

module Fission.User.Registration.Types
data Registration
Registration :: !Username -> !Email -> !Maybe Password -> Registration
[$sel:username:Registration] :: Registration -> !Username
[$sel:email:Registration] :: Registration -> !Email
[$sel:password:Registration] :: Registration -> !Maybe Password
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.User.Registration.Types.Registration
instance Data.Aeson.Types.ToJSON.ToJSON Fission.User.Registration.Types.Registration
instance Data.Aeson.Types.FromJSON.FromJSON Fission.User.Registration.Types.Registration
instance Data.Swagger.Internal.Schema.ToSchema Fission.User.Registration.Types.Registration

module Fission.User.Types

module Fission.User.Provision.Types
data Provision
Provision :: BaseUrl -> Username -> Secret -> Provision
[$sel:url:Provision] :: Provision -> BaseUrl
[$sel:username:Provision] :: Provision -> Username
[$sel:password:Provision] :: Provision -> Secret
instance GHC.Generics.Generic Fission.User.Provision.Types.Provision
instance GHC.Show.Show Fission.User.Provision.Types.Provision
instance GHC.Classes.Eq Fission.User.Provision.Types.Provision
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.User.Provision.Types.Provision
instance Data.Aeson.Types.FromJSON.FromJSON Fission.User.Provision.Types.Provision
instance Data.Aeson.Types.ToJSON.ToJSON Fission.User.Provision.Types.Provision
instance Data.Swagger.Internal.Schema.ToSchema Fission.User.Provision.Types.Provision

module Fission.Email.SendInBlue.TemplateOptions.Types
data TemplateOptions
TemplateOptions :: !BaseUrl -> !Username -> TemplateOptions
[$sel:verifyLink:TemplateOptions] :: TemplateOptions -> !BaseUrl
[$sel:username:TemplateOptions] :: TemplateOptions -> !Username
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Email.SendInBlue.TemplateOptions.Types.TemplateOptions

module Fission.Email.Recipient.Types
data Recipient
Recipient :: !Email -> !Username -> Recipient
[$sel:email:Recipient] :: Recipient -> !Email
[$sel:name:Recipient] :: Recipient -> !Username
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Email.Recipient.Types.Recipient

module Fission.Email.SendInBlue.Request.Types
data Request
Request :: !TemplateId -> !NonEmpty Recipient -> !TemplateOptions -> Request
[$sel:templateId:Request] :: Request -> !TemplateId
[$sel:to:Request] :: Request -> !NonEmpty Recipient
[$sel:params:Request] :: Request -> !TemplateOptions
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Email.SendInBlue.Request.Types.Request

module Fission.Email.SendInBlue.Types

module Fission.Email.Types

module Fission.Email.SendInBlue.Client
type SendEmailAPI = "v3" :> "smtp" :> "email" :> Header "api-key" Text :> ReqBody '[JSON] Request :> Post '[JSON] Response
sendEmail :: ApiKey -> Request -> ClientM Response

module Fission.Email.Class
class Monad m => MonadEmail m
sendVerificationEmail :: MonadEmail m => Recipient -> Challenge -> m (Either ClientError Response)

module Fission.Email

module Fission.Web.Auth.Class
class Monad m => MonadAuth who m

-- | Check that some entity is authenticated and authorized
getVerifier :: MonadAuth who m => m (AuthHandler Request who)

module Fission.Web.Auth.Token.Basic.Class
class Monad m => MonadBasicAuth who m

-- | Check that some entity is authenticated and authorized
getVerifier :: MonadBasicAuth who m => m (BasicAuthCheck who)


-- | Authorization types; primarily more semantic aliases
module Fission.Web.Auth.Token.Basic.Types
newtype Token
Token :: ByteString -> Token
[$sel:unToken:Token] :: Token -> ByteString
instance GHC.Classes.Eq Fission.Web.Auth.Token.Basic.Types.Token
instance GHC.Show.Show Fission.Web.Auth.Token.Basic.Types.Token
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.Basic.Types.Token
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.Basic.Types.Token
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.Basic.Types.Token
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.Basic.Types.Token
instance Web.Internal.HttpApiData.ToHttpApiData Fission.Web.Auth.Token.Basic.Types.Token
instance Web.Internal.HttpApiData.FromHttpApiData Fission.Web.Auth.Token.Basic.Types.Token


-- | JOSE <tt>"cty"</tt> (Content Type) Header Parameter
module Fission.Web.Auth.Token.JWT.Header.Cty.Types

-- | RFC 7519 https:/<i>tools.ietf.org</i>html/rfc7519
--   
--   <ol>
--   <li>2. "cty" (Content Type) Header Parameter</li>
--   </ol>
--   
--   The "cty" (content type) Header Parameter defined by [JWS] and [JWE]
--   is used by this specification to convey structural information about
--   the JWT.
--   
--   In the normal case in which nested signing or encryption operations
--   are not employed, the use of this Header Parameter is NOT RECOMMENDED.
--   In the case that nested signing or encryption is employed, this Header
--   Parameter MUST be present; in this case, the value MUST be <a>JWT</a>,
--   to indicate that a Nested JWT is carried in this JWT. While media type
--   names are not case sensitive, it is RECOMMENDED that <a>JWT</a> always
--   be spelled using uppercase characters for compatibility with legacy
--   implementations. See Appendix A.2 for an example of a Nested JWT.
data Cty
JWT :: Cty
instance GHC.Read.Read Fission.Web.Auth.Token.JWT.Header.Cty.Types.Cty
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Header.Cty.Types.Cty
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Header.Cty.Types.Cty
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.JWT.Header.Cty.Types.Cty
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Header.Cty.Types.Cty
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.JWT.Header.Cty.Types.Cty


-- | JOSE <tt>"typ"</tt> (Type) Header Parameter
module Fission.Web.Auth.Token.JWT.Header.Typ.Types
data Typ
JWT :: Typ
instance GHC.Read.Read Fission.Web.Auth.Token.JWT.Header.Typ.Types.Typ
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Header.Typ.Types.Typ
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Header.Typ.Types.Typ
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.JWT.Header.Typ.Types.Typ
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.JWT.Header.Typ.Types.Typ
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Header.Typ.Types.Typ


-- | JWT Header as specific in RFC 7519
module Fission.Web.Auth.Token.JWT.Header.Types
data Header
Header :: !Typ -> !Algorithm -> !Maybe Cty -> !SemVer -> Header

-- | Standard JWT '"typ"' field
[$sel:typ:Header] :: Header -> !Typ

-- | Standard JWT '"alg"' field
[$sel:alg:Header] :: Header -> !Algorithm

-- | Standard JWT '"cty"' field. Set to '<a>JWT</a>' if there's a recursive
--   JWT in the claims
[$sel:cty:Header] :: Header -> !Maybe Cty

-- | UCAN Version, mainly to state assumptions
[$sel:uav:Header] :: Header -> !SemVer
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Header.Types.Header
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Header.Types.Header
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.JWT.Header.Types.Header
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Header.Types.Header
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.JWT.Header.Types.Header

module Fission.Web.Auth.Token.JWT.RawContent.Types

-- | Newtype wrapper for raw content (i.e. the part that gets signed &amp;
--   verified)
newtype RawContent
RawContent :: Text -> RawContent
[$sel:unRawContent:RawContent] :: RawContent -> Text
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.RawContent.Types.RawContent
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.RawContent.Types.RawContent
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.RawContent.Types.RawContent

module Fission.Web.Auth.Token.JWT.RawContent

-- | Smart constructor for <a>RawContent</a>
contentOf :: Text -> RawContent

module Fission.Web.Auth.Token.JWT.Signature.RS256.Types
newtype Signature
Signature :: ByteString -> Signature
[$sel:unSignature:Signature] :: Signature -> ByteString
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Signature.RS256.Types.Signature
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Signature.RS256.Types.Signature
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.JWT.Signature.RS256.Types.Signature
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.JWT.Signature.RS256.Types.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Signature.RS256.Types.Signature
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Signature.RS256.Types.Signature
instance Data.ByteArray.Types.ByteArrayAccess Fission.Web.Auth.Token.JWT.Signature.RS256.Types.Signature

module Fission.Web.Auth.Token.JWT.Signature.Types
data Signature
Ed25519 :: Signature -> Signature
RS256 :: Signature -> Signature
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Signature.Types.Signature
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Signature.Types.Signature
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Signature.Types.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Signature.Types.Signature
instance Data.ByteArray.Types.ByteArrayAccess Fission.Web.Auth.Token.JWT.Signature.Types.Signature

module Fission.Web.Auth.Token.JWT.Signature
parse :: Algorithm -> Value -> Parser Signature

module Fission.Web.Auth.Token.UCAN.Resource.Scope.Types
data Scope subset
Complete :: Scope subset
Subset :: subset -> Scope subset
instance GHC.Show.Show subset => GHC.Show.Show (Fission.Web.Auth.Token.UCAN.Resource.Scope.Types.Scope subset)
instance GHC.Classes.Eq subset => GHC.Classes.Eq (Fission.Web.Auth.Token.UCAN.Resource.Scope.Types.Scope subset)
instance Test.QuickCheck.Arbitrary.Arbitrary subset => Test.QuickCheck.Arbitrary.Arbitrary (Fission.Web.Auth.Token.UCAN.Resource.Scope.Types.Scope subset)
instance Data.Aeson.Types.ToJSON.ToJSON sub => Data.Aeson.Types.ToJSON.ToJSON (Fission.Web.Auth.Token.UCAN.Resource.Scope.Types.Scope sub)
instance Data.Aeson.Types.FromJSON.FromJSON sub => Data.Aeson.Types.FromJSON.FromJSON (Fission.Web.Auth.Token.UCAN.Resource.Scope.Types.Scope sub)

module Fission.Web.Client.Auth.Class
class Monad m => MonadWebAuth m auth
getAuth :: MonadWebAuth m auth => m auth

module Fission.Web.Client.Auth
withAuth :: MonadWebAuth m auth => (auth -> a) -> m a

module Fission.Web.Client.Class
class Monad m => MonadWebClient m
sendRequest :: MonadWebClient m => ClientM a -> m (Either ClientError a)

module Fission.Web.Client.Types
newtype Runner
Runner :: (forall a. ClientM a -> IO (Either ClientError a)) -> Runner
[$sel:getRunner:Runner] :: Runner -> forall a. ClientM a -> IO (Either ClientError a)

module Fission.Web.Error.Class
class ToServerError err
toServerError :: ToServerError err => err -> ServerError
instance Fission.Web.Error.Class.ToServerError Servant.Server.Internal.ServerError.ServerError
instance Fission.Web.Error.Class.ToServerError GHC.Types.Int
instance Fission.Web.Error.Class.ToServerError Network.IPFS.Error.Error
instance Fission.Web.Error.Class.ToServerError Network.IPFS.Get.Error.Error
instance Fission.Web.Error.Class.ToServerError Network.IPFS.Add.Error.Error
instance Fission.Web.Error.Class.ToServerError Network.IPFS.Peer.Error.Error
instance Fission.Web.Error.Class.ToServerError Network.IPFS.Error.Linearization
instance Fission.Web.Error.Class.ToServerError (Data.WorldPeace.Union.OpenUnion '[])
instance (Fission.Web.Error.Class.ToServerError a, Fission.Web.Error.Class.ToServerError (Data.WorldPeace.Union.OpenUnion as)) => Fission.Web.Error.Class.ToServerError (Data.WorldPeace.Union.OpenUnion (a : as))


-- | Web error handling, common patterns, and other helpers
module Fission.Web.Error
ensure :: (MonadLogger m, MonadThrow m, Display err, ToServerError err) => Either err a -> m a
ensureM :: (MonadLogger m, MonadThrow m, Display err, ToServerError err) => m (Either err a) -> m a
ensureMaybe :: (MonadLogger m, MonadThrow m, Display err, ToServerError err) => err -> Maybe a -> m a
throw :: (MonadLogger m, MonadThrow m, Display err, ToServerError err) => err -> m a
withMessage :: Display err => err -> ServerError -> ServerError

module Fission.Web.Auth.Error
data Error
NoToken :: Error
CannotParse :: Text -> Error
NoSuchUser :: Error
Unauthorized :: Error
instance GHC.Show.Show Fission.Web.Auth.Error.Error
instance GHC.Classes.Eq Fission.Web.Auth.Error.Error
instance GHC.Exception.Type.Exception Fission.Web.Auth.Error.Error
instance RIO.Prelude.Display.Display Fission.Web.Auth.Error.Error
instance Fission.Web.Error.Class.ToServerError Fission.Web.Auth.Error.Error


-- | Username errors
module Fission.User.Username.Error
data Invalid
Invalid :: Invalid
instance GHC.Exception.Type.Exception Fission.User.Username.Error.Invalid
instance GHC.Classes.Eq Fission.User.Username.Error.Invalid
instance GHC.Show.Show Fission.User.Username.Error.Invalid
instance RIO.Prelude.Display.Display Fission.User.Username.Error.Invalid
instance Fission.Web.Error.Class.ToServerError Fission.User.Username.Error.Invalid


-- | Username validation
module Fission.User.Username.Validation
check :: Username -> Either Invalid Username

-- | Confirm that a username is valid
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "simple")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "happy-name")
--   True
--   </pre>
--   
--   Blocklisted words are not allowed
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "recovery")
--   False
--   </pre>
--   
--   They're not case sensitive
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "reCovErY")
--   False
--   </pre>
--   
--   Nor are various characters
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "under_score")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "plus+plus")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "-startswith")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "endswith-")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "with.space")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "with.dot")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "has.two.dots")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValid (Username "name&amp;with#chars")
--   False
--   </pre>
isValid :: Username -> Bool
isUsernameChar :: Char -> Bool


-- | Top-level username module
module Fission.User.Username

module Fission.User.Password.Error
data FailedDigest
FailedDigest :: FailedDigest
instance GHC.Exception.Type.Exception Fission.User.Password.Error.FailedDigest
instance GHC.Classes.Eq Fission.User.Password.Error.FailedDigest
instance GHC.Show.Show Fission.User.Password.Error.FailedDigest
instance RIO.Prelude.Display.Display Fission.User.Password.Error.FailedDigest
instance Fission.Web.Error.Class.ToServerError Fission.User.Password.Error.FailedDigest

module Fission.User.Password

-- | Generate a password for a <tt>User</tt>.
random :: MonadIO m => m Password
hashPassword :: MonadIO m => Password -> m (Either FailedDigest Text)

module Fission.User.Creator.Error
data AlreadyExists
ConflictingUsername :: Username -> AlreadyExists
ConflictingPublicKey :: Public -> AlreadyExists
instance GHC.Exception.Type.Exception Fission.User.Creator.Error.AlreadyExists
instance GHC.Classes.Eq Fission.User.Creator.Error.AlreadyExists
instance GHC.Show.Show Fission.User.Creator.Error.AlreadyExists
instance RIO.Prelude.Display.Display Fission.User.Creator.Error.AlreadyExists
instance Fission.Web.Error.Class.ToServerError Fission.User.Creator.Error.AlreadyExists

module Fission.Web.Auth.Token.JWT.Signature.Error
data Error
InvalidPublicKey :: Error
InvalidSignature :: Error
SignatureDoesNotMatch :: Error
instance GHC.Exception.Type.Exception Fission.Web.Auth.Token.JWT.Signature.Error.Error
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Signature.Error.Error
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Signature.Error.Error
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Signature.Error.Error
instance Fission.Web.Error.Class.ToServerError Fission.Web.Auth.Token.JWT.Signature.Error.Error

module Fission.Web.Auth.Token.JWT.Resolver.Error
data Error
CannotResolve :: CID -> Error -> Error
InvalidJWT :: ByteString -> Error
instance GHC.Exception.Type.Exception Fission.Web.Auth.Token.JWT.Resolver.Error.Error
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Resolver.Error.Error
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Resolver.Error.Error
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Resolver.Error.Error
instance Fission.Web.Error.Class.ToServerError Fission.Web.Auth.Token.JWT.Resolver.Error.Error

module Fission.Web.Auth.Token.JWT.Header.Error
data Error
UnsupportedVersion :: Error
UnsupportedAlgorithm :: Error
instance GHC.Exception.Type.Exception Fission.Web.Auth.Token.JWT.Header.Error.Error
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Header.Error.Error
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Header.Error.Error
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Header.Error.Error
instance Fission.Web.Error.Class.ToServerError Fission.Web.Auth.Token.JWT.Header.Error.Error

module Fission.URL.Errors
data InvalidURL
InvalidURL :: InvalidURL
instance GHC.Show.Show Fission.URL.Errors.InvalidURL
instance GHC.Classes.Eq Fission.URL.Errors.InvalidURL
instance RIO.Prelude.Display.Display Fission.URL.Errors.InvalidURL
instance Fission.Web.Error.Class.ToServerError Fission.URL.Errors.InvalidURL

module Fission.URL
prefix' :: Subdomain -> URL -> URL
zeroOrOneSubdomain :: URL -> Either InvalidURL URL

module Fission.Web.Auth.Token.UCAN.Resource.Types
data Resource

-- | Fission FileSystem path
FissionFileSystem :: FilePath -> Resource

-- | Primary URL for an App
FissionApp :: Scope URL -> Resource

-- | Any domain name to which we have DNS access
RegisteredDomain :: Scope DomainName -> Resource
instance GHC.Show.Show Fission.Web.Auth.Token.UCAN.Resource.Types.Resource
instance GHC.Classes.Eq Fission.Web.Auth.Token.UCAN.Resource.Types.Resource
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.UCAN.Resource.Types.Resource
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.UCAN.Resource.Types.Resource
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.UCAN.Resource.Types.Resource

module Fission.Web.Auth.Token.JWT

-- | An RFC 7519 extended with support for Ed25519 keys, and some specifics
--   (claims, etc) for Fission's use case
data JWT
JWT :: !Header -> !Claims -> !Signature -> JWT
[$sel:header:JWT] :: JWT -> !Header
[$sel:claims:JWT] :: JWT -> !Claims
[$sel:sig:JWT] :: JWT -> !Signature
data Claims
Claims :: !DID -> !DID -> !Scope Resource -> !Potency -> !Proof -> !UTCTime -> !UTCTime -> Claims
[$sel:sender:Claims] :: Claims -> !DID
[$sel:receiver:Claims] :: Claims -> !DID
[$sel:resource:Claims] :: Claims -> !Scope Resource
[$sel:potency:Claims] :: Claims -> !Potency
[$sel:proof:Claims] :: Claims -> !Proof
[$sel:exp:Claims] :: Claims -> !UTCTime
[$sel:nbf:Claims] :: Claims -> !UTCTime
data Proof
RootCredential :: Proof
Nested :: RawContent -> JWT -> Proof
Reference :: CID -> Proof
signEd25519 :: Header -> Claims -> SecretKey -> Signature
signRS256 :: MonadRandom m => Header -> Claims -> PrivateKey -> m (Either Error Signature)
data Header
Header :: !Typ -> !Algorithm -> !Maybe Cty -> !SemVer -> Header

-- | Standard JWT '"typ"' field
[$sel:typ:Header] :: Header -> !Typ

-- | Standard JWT '"alg"' field
[$sel:alg:Header] :: Header -> !Algorithm

-- | Standard JWT '"cty"' field. Set to '<a>JWT</a>' if there's a recursive
--   JWT in the claims
[$sel:cty:Header] :: Header -> !Maybe Cty

-- | UCAN Version, mainly to state assumptions
[$sel:uav:Header] :: Header -> !SemVer
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Claims
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.JWT
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.JWT
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Proof
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Proof
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.JWT.JWT
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.JWT
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.JWT.JWT
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Claims
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Claims
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.JWT.Claims
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Claims
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.JWT.Claims
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.JWT.Proof
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Proof
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.JWT.Proof

module Fission.Web.Auth.Token.JWT.Resolver.Class
class Monad m => Resolver m
resolve :: Resolver m => CID -> m (Either Error (RawContent, JWT))

module Fission.Web.Auth.Token.JWT.Resolver

module Fission.Web.Auth.Token.JWT.Proof.Error
data Error
InvalidSignatureChain :: Error
ScopeOutOfBounds :: Error
PotencyEscelation :: Error
TimeNotSubset :: Error
ResolverError :: Error -> Error
instance GHC.Exception.Type.Exception Fission.Web.Auth.Token.JWT.Proof.Error.Error
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Proof.Error.Error
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Proof.Error.Error
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Proof.Error.Error
instance Fission.Web.Error.Class.ToServerError Fission.Web.Auth.Token.JWT.Proof.Error.Error

module Fission.Web.Auth.Token.JWT.Claims.Error
data Error
Expired :: Error
TooEarly :: Error
IncorrectReceiver :: Error
ProofError :: Error -> Error
instance GHC.Exception.Type.Exception Fission.Web.Auth.Token.JWT.Claims.Error.Error
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Claims.Error.Error
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Claims.Error.Error
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Claims.Error.Error
instance Fission.Web.Error.Class.ToServerError Fission.Web.Auth.Token.JWT.Claims.Error.Error

module Fission.Web.Auth.Token.JWT.Error
data Error
ParseError :: Error
HeaderError :: Error -> Error
ClaimsError :: Error -> Error
SignatureError :: Error -> Error
instance GHC.Show.Show Fission.Web.Auth.Token.JWT.Error.Error
instance GHC.Classes.Eq Fission.Web.Auth.Token.JWT.Error.Error
instance GHC.Exception.Type.Exception Fission.Web.Auth.Token.JWT.Error.Error
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.JWT.Error.Error
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.JWT.Error.Error
instance Fission.Web.Error.Class.ToServerError Fission.Web.Auth.Token.JWT.Error.Error

module Fission.Web.Auth.Token.JWT.Proof
delegatedInBounds :: JWT -> JWT -> Either Error JWT
signaturesMatch :: JWT -> JWT -> Either Error JWT
resourceInSubset :: JWT -> JWT -> Either Error JWT
potencyInSubset :: JWT -> JWT -> Either Error JWT


-- | Authorization types; primarily more semantic aliases
module Fission.Web.Auth.Token.Bearer.Types
data Token
Token :: !JWT -> !RawContent -> Token

-- | The actual token
[$sel:jwt:Token] :: Token -> !JWT

-- | Primarily to pass in to the verifier
[$sel:rawContent:Token] :: Token -> !RawContent
instance GHC.Classes.Eq Fission.Web.Auth.Token.Bearer.Types.Token
instance GHC.Show.Show Fission.Web.Auth.Token.Bearer.Types.Token
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.Bearer.Types.Token
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.Bearer.Types.Token
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.Bearer.Types.Token
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.Bearer.Types.Token
instance Web.Internal.HttpApiData.ToHttpApiData Fission.Web.Auth.Token.Bearer.Types.Token
instance Web.Internal.HttpApiData.FromHttpApiData Fission.Web.Auth.Token.Bearer.Types.Token

module Fission.Web.Auth.Token.Types
data Token
Basic :: Token -> Token
Bearer :: Token -> Token
instance GHC.Classes.Eq Fission.Web.Auth.Token.Types.Token
instance GHC.Show.Show Fission.Web.Auth.Token.Types.Token
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.Auth.Token.Types.Token
instance RIO.Prelude.Display.Display Fission.Web.Auth.Token.Types.Token
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Auth.Token.Types.Token
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Auth.Token.Types.Token
instance Web.Internal.HttpApiData.ToHttpApiData Fission.Web.Auth.Token.Types.Token
instance Web.Internal.HttpApiData.FromHttpApiData Fission.Web.Auth.Token.Types.Token

module Fission.Web.Auth.Token.Bearer


-- | A real world example with a nested proof
module Fission.Internal.Fixture.Bearer.Nested
jsonRSA2048 :: Text
tokenRSA2048 :: Token
jwtRSA2048 :: JWT
rawContent :: RawContent
validTime :: UTCTime
newtype InTimeBounds a
InTimeBounds :: Identity a -> InTimeBounds a
[$sel:unwrap:InTimeBounds] :: InTimeBounds a -> Identity a
instance GHC.Show.Show a => GHC.Show.Show (Fission.Internal.Fixture.Bearer.Nested.InTimeBounds a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Fission.Internal.Fixture.Bearer.Nested.InTimeBounds a)
instance GHC.Base.Monad Fission.Internal.Fixture.Bearer.Nested.InTimeBounds
instance GHC.Base.Applicative Fission.Internal.Fixture.Bearer.Nested.InTimeBounds
instance GHC.Base.Functor Fission.Internal.Fixture.Bearer.Nested.InTimeBounds
instance Fission.Web.Auth.Token.JWT.Resolver.Class.Resolver Fission.Internal.Fixture.Bearer.Nested.InTimeBounds
instance Fission.Authorization.ServerDID.Class.ServerDID Fission.Internal.Fixture.Bearer.Nested.InTimeBounds
instance Control.Monad.Time.MonadTime Fission.Internal.Fixture.Bearer.Nested.InTimeBounds

module Fission.Internal.Fixture.Bearer
jsonRSA2048 :: Text
tokenRSA2048 :: Token
jwtRSA2048 :: JWT
rawContent :: RawContent
validTime :: UTCTime

module Fission.Models
data HerokuAddOn
HerokuAddOn :: !UUID -> !Maybe Region -> !UTCTime -> !UTCTime -> HerokuAddOn
[$sel:herokuAddOnUuid:HerokuAddOn] :: HerokuAddOn -> !UUID
[$sel:herokuAddOnRegion:HerokuAddOn] :: HerokuAddOn -> !Maybe Region
[$sel:herokuAddOnInsertedAt:HerokuAddOn] :: HerokuAddOn -> !UTCTime
[$sel:herokuAddOnModifiedAt:HerokuAddOn] :: HerokuAddOn -> !UTCTime
type HerokuAddOnId = Key HerokuAddOn
data User
User :: !Maybe Public -> ![PublicKey] -> !Maybe Email -> !Username -> !Role -> !Bool -> !Bool -> !CID -> !Bytes -> !Maybe (Key HerokuAddOn) -> !Maybe SecretDigest -> !UTCTime -> !UTCTime -> User
[$sel:userPublicKey:User] :: User -> !Maybe Public
[$sel:userExchangeKeys:User] :: User -> ![PublicKey]
[$sel:userEmail:User] :: User -> !Maybe Email
[$sel:userUsername:User] :: User -> !Username
[$sel:userRole:User] :: User -> !Role
[$sel:userActive:User] :: User -> !Bool
[$sel:userVerified:User] :: User -> !Bool
[$sel:userDataRoot:User] :: User -> !CID
[$sel:userDataRootSize:User] :: User -> !Bytes
[$sel:userHerokuAddOnId:User] :: User -> !Maybe (Key HerokuAddOn)
[$sel:userSecretDigest:User] :: User -> !Maybe SecretDigest
[$sel:userInsertedAt:User] :: User -> !UTCTime
[$sel:userModifiedAt:User] :: User -> !UTCTime
type UserId = Key User
data UserChallenge
UserChallenge :: !Key User -> !Challenge -> UserChallenge
[$sel:userChallengeUserId:UserChallenge] :: UserChallenge -> !Key User
[$sel:userChallengeHash:UserChallenge] :: UserChallenge -> !Challenge
type UserChallengeId = Key UserChallenge
data UpdateUserDataRootEvent
UpdateUserDataRootEvent :: !Key User -> !CID -> !Bytes -> !UTCTime -> UpdateUserDataRootEvent
[$sel:updateUserDataRootEventUserId:UpdateUserDataRootEvent] :: UpdateUserDataRootEvent -> !Key User
[$sel:updateUserDataRootEventNewDataRoot:UpdateUserDataRootEvent] :: UpdateUserDataRootEvent -> !CID
[$sel:updateUserDataRootEventNewDataRootSize:UpdateUserDataRootEvent] :: UpdateUserDataRootEvent -> !Bytes
[$sel:updateUserDataRootEventInsertedAt:UpdateUserDataRootEvent] :: UpdateUserDataRootEvent -> !UTCTime
type UpdateUserDataRootEventId = Key UpdateUserDataRootEvent
data LoosePin
LoosePin :: !Key User -> !CID -> !UTCTime -> LoosePin
[$sel:loosePinOwnerId:LoosePin] :: LoosePin -> !Key User
[$sel:loosePinCid:LoosePin] :: LoosePin -> !CID
[$sel:loosePinInsertedAt:LoosePin] :: LoosePin -> !UTCTime
type LoosePinId = Key LoosePin
data Domain
Domain :: !DomainName -> !Key User -> !ZoneID -> !UTCTime -> !UTCTime -> Domain
[$sel:domainDomainName:Domain] :: Domain -> !DomainName
[$sel:domainOwnerId:Domain] :: Domain -> !Key User
[$sel:domainZoneId:Domain] :: Domain -> !ZoneID
[$sel:domainInsertedAt:Domain] :: Domain -> !UTCTime
[$sel:domainModifiedAt:Domain] :: Domain -> !UTCTime
type DomainId = Key Domain
data App
App :: !Key User -> !CID -> !Bytes -> !UTCTime -> !UTCTime -> App
[$sel:appOwnerId:App] :: App -> !Key User
[$sel:appCid:App] :: App -> !CID
[$sel:appSize:App] :: App -> !Bytes
[$sel:appInsertedAt:App] :: App -> !UTCTime
[$sel:appModifiedAt:App] :: App -> !UTCTime
type AppId = Key App
data CreateAppEvent
CreateAppEvent :: !Key App -> !Key User -> !CID -> !Bytes -> !UTCTime -> CreateAppEvent
[$sel:createAppEventAppId:CreateAppEvent] :: CreateAppEvent -> !Key App
[$sel:createAppEventOwnerId:CreateAppEvent] :: CreateAppEvent -> !Key User
[$sel:createAppEventCid:CreateAppEvent] :: CreateAppEvent -> !CID
[$sel:createAppEventSize:CreateAppEvent] :: CreateAppEvent -> !Bytes
[$sel:createAppEventInsertedAt:CreateAppEvent] :: CreateAppEvent -> !UTCTime
type CreateAppEventId = Key CreateAppEvent
data DestroyAppEvent
DestroyAppEvent :: !Key App -> !UTCTime -> DestroyAppEvent
[$sel:destroyAppEventAppId:DestroyAppEvent] :: DestroyAppEvent -> !Key App
[$sel:destroyAppEventInsertedAt:DestroyAppEvent] :: DestroyAppEvent -> !UTCTime
type DestroyAppEventId = Key DestroyAppEvent
data SetAppCIDEvent
SetAppCIDEvent :: !Key App -> !CID -> !Bytes -> !UTCTime -> SetAppCIDEvent
[$sel:setAppCIDEventAppId:SetAppCIDEvent] :: SetAppCIDEvent -> !Key App
[$sel:setAppCIDEventNewCID:SetAppCIDEvent] :: SetAppCIDEvent -> !CID
[$sel:setAppCIDEventNewCIDSize:SetAppCIDEvent] :: SetAppCIDEvent -> !Bytes
[$sel:setAppCIDEventInsertedAt:SetAppCIDEvent] :: SetAppCIDEvent -> !UTCTime
type SetAppCIDEventId = Key SetAppCIDEvent
data AppDomain
AppDomain :: !Key App -> !DomainName -> !Maybe Subdomain -> !Checkmark -> !UTCTime -> AppDomain
[$sel:appDomainAppId:AppDomain] :: AppDomain -> !Key App
[$sel:appDomainDomainName:AppDomain] :: AppDomain -> !DomainName
[$sel:appDomainSubdomain:AppDomain] :: AppDomain -> !Maybe Subdomain
[$sel:appDomainIsPrimary:AppDomain] :: AppDomain -> !Checkmark
[$sel:appDomainInsertedAt:AppDomain] :: AppDomain -> !UTCTime
type AppDomainId = Key AppDomain
data AssociateAppDomainEvent
AssociateAppDomainEvent :: !Key App -> !DomainName -> !Maybe Subdomain -> !UTCTime -> AssociateAppDomainEvent
[$sel:associateAppDomainEventAppId:AssociateAppDomainEvent] :: AssociateAppDomainEvent -> !Key App
[$sel:associateAppDomainEventDomainName:AssociateAppDomainEvent] :: AssociateAppDomainEvent -> !DomainName
[$sel:associateAppDomainEventSubdomain:AssociateAppDomainEvent] :: AssociateAppDomainEvent -> !Maybe Subdomain
[$sel:associateAppDomainEventInsertedAt:AssociateAppDomainEvent] :: AssociateAppDomainEvent -> !UTCTime
type AssociateAppDomainEventId = Key AssociateAppDomainEvent
data DissociateAppDomainEvent
DissociateAppDomainEvent :: !Key App -> !DomainName -> !Maybe Subdomain -> !UTCTime -> DissociateAppDomainEvent
[$sel:dissociateAppDomainEventAppId:DissociateAppDomainEvent] :: DissociateAppDomainEvent -> !Key App
[$sel:dissociateAppDomainEventDomainName:DissociateAppDomainEvent] :: DissociateAppDomainEvent -> !DomainName
[$sel:dissociateAppDomainEventSubdomain:DissociateAppDomainEvent] :: DissociateAppDomainEvent -> !Maybe Subdomain
[$sel:dissociateAppDomainEventInsertedAt:DissociateAppDomainEvent] :: DissociateAppDomainEvent -> !UTCTime
type DissociateAppDomainEventId = Key DissociateAppDomainEvent
migrateAll :: Migration
instance GHC.Classes.Eq Fission.Models.DissociateAppDomainEvent
instance GHC.Show.Show Fission.Models.DissociateAppDomainEvent
instance GHC.Classes.Eq Fission.Models.AssociateAppDomainEvent
instance GHC.Show.Show Fission.Models.AssociateAppDomainEvent
instance GHC.Classes.Eq Fission.Models.AppDomain
instance GHC.Show.Show Fission.Models.AppDomain
instance GHC.Classes.Eq Fission.Models.SetAppCIDEvent
instance GHC.Show.Show Fission.Models.SetAppCIDEvent
instance GHC.Classes.Eq Fission.Models.DestroyAppEvent
instance GHC.Show.Show Fission.Models.DestroyAppEvent
instance GHC.Classes.Eq Fission.Models.CreateAppEvent
instance GHC.Show.Show Fission.Models.CreateAppEvent
instance GHC.Classes.Eq Fission.Models.App
instance GHC.Show.Show Fission.Models.App
instance GHC.Classes.Eq Fission.Models.Domain
instance GHC.Show.Show Fission.Models.Domain
instance GHC.Classes.Eq Fission.Models.LoosePin
instance GHC.Show.Show Fission.Models.LoosePin
instance GHC.Classes.Eq Fission.Models.UpdateUserDataRootEvent
instance GHC.Show.Show Fission.Models.UpdateUserDataRootEvent
instance GHC.Classes.Eq Fission.Models.UserChallenge
instance GHC.Show.Show Fission.Models.UserChallenge
instance GHC.Classes.Eq Fission.Models.User
instance GHC.Show.Show Fission.Models.User
instance GHC.Classes.Eq Fission.Models.HerokuAddOn
instance GHC.Show.Show Fission.Models.HerokuAddOn
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.HerokuAddOn)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Unique Fission.Models.HerokuAddOn)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.User)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Unique Fission.Models.User)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.UserChallenge)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Unique Fission.Models.UserChallenge)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.UpdateUserDataRootEvent)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.LoosePin)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Unique Fission.Models.LoosePin)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.Domain)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Unique Fission.Models.Domain)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.App)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.CreateAppEvent)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.DestroyAppEvent)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.SetAppCIDEvent)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.AppDomain)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Unique Fission.Models.AppDomain)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.AssociateAppDomainEvent)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Fission.Models.DissociateAppDomainEvent)
instance Database.Persist.Class.PersistField.PersistField Fission.Models.DissociateAppDomainEvent
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.DissociateAppDomainEvent
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.DissociateAppDomainEvent
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.DissociateAppDomainEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.DissociateAppDomainEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.DissociateAppDomainEvent
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.DissociateAppDomainEvent GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.DissociateAppDomainEvent backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.AssociateAppDomainEvent
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.AssociateAppDomainEvent
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.AssociateAppDomainEvent
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.AssociateAppDomainEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.AssociateAppDomainEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.AssociateAppDomainEvent
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.AssociateAppDomainEvent GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.AssociateAppDomainEvent backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.AppDomain
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.AppDomain
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.AppDomain
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.AppDomain
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.AppDomain
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.AppDomain
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.AppDomain GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.AppDomain backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.SetAppCIDEvent
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.SetAppCIDEvent
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.SetAppCIDEvent
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.SetAppCIDEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.SetAppCIDEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.SetAppCIDEvent
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.SetAppCIDEvent GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.SetAppCIDEvent backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.DestroyAppEvent
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.DestroyAppEvent
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.DestroyAppEvent
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.DestroyAppEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.DestroyAppEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.DestroyAppEvent
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.DestroyAppEvent GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.DestroyAppEvent backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.CreateAppEvent
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.CreateAppEvent
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.CreateAppEvent
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.CreateAppEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.CreateAppEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.CreateAppEvent
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.CreateAppEvent GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.CreateAppEvent backend
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Models.AppId
instance Data.Swagger.Internal.Schema.ToSchema Fission.Models.AppId
instance Data.Swagger.Internal.ParamSchema.ToParamSchema Fission.Models.AppId
instance RIO.Prelude.Display.Display Fission.Models.AppId
instance Data.Aeson.Types.ToJSON.ToJSONKey Fission.Models.AppId
instance Database.Persist.Class.PersistField.PersistField Fission.Models.App
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.App
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.App
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.App
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.App
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.App
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.App GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.App backend
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.Domain
instance Database.Persist.Class.PersistField.PersistField Fission.Models.Domain
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.Domain
instance Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.Domain
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.Domain
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.Domain GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.Domain backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.LoosePin
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.LoosePin
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.LoosePin
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.LoosePin
instance Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.LoosePin
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.LoosePin
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.LoosePin GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.LoosePin backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.UpdateUserDataRootEvent
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.UpdateUserDataRootEvent
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.UpdateUserDataRootEvent
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.UpdateUserDataRootEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.UpdateUserDataRootEvent
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.UpdateUserDataRootEvent
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.UpdateUserDataRootEvent GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.UpdateUserDataRootEvent backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.UserChallenge
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.UserChallenge
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.UserChallenge
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.UserChallenge
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.UserChallenge
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.UserChallenge
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.UserChallenge GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.UserChallenge backend
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Models.UserId
instance RIO.Prelude.Display.Display Fission.Models.UserId
instance Fission.Security.Digestable Fission.Models.UserId
instance Data.Swagger.Internal.Schema.ToSchema Fission.Models.UserId
instance Database.Persist.Class.PersistField.PersistField Fission.Models.User
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.User
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.User
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.User
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.User
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.User
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.User GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.User backend
instance Database.Persist.Class.PersistField.PersistField Fission.Models.HerokuAddOn
instance Database.Persist.Sql.Class.PersistFieldSql Fission.Models.HerokuAddOn
instance Database.Persist.Class.PersistEntity.PersistEntity Fission.Models.HerokuAddOn
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Fission.Models.HerokuAddOn
instance Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Fission.Models.HerokuAddOn
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Fission.Models.HerokuAddOn
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Fission.Models.HerokuAddOn GHC.Types.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Fission.Models.HerokuAddOn backend


-- | Validate user
module Fission.User.Validation
check :: User -> Either Invalid User
isValid :: User -> Bool

module Fission.User.Retriever.Class
class Monad m => Retriever m
getById :: Retriever m => UserId -> m (Maybe (Entity User))
getByUsername :: Retriever m => Username -> m (Maybe (Entity User))
getByPublicKey :: Retriever m => Public -> m (Maybe (Entity User))
getByHerokuAddOnId :: Retriever m => HerokuAddOnId -> m (Maybe (Entity User))
getByEmail :: Retriever m => Email -> m (Maybe (Entity User))
instance Control.Monad.IO.Class.MonadIO m => Fission.User.Retriever.Class.Retriever (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.User.Retriever

module Fission.Platform.Heroku.Provision.Types

-- | Response Parameters
--   
--   From Heroku
--   
--   <pre>
--   In addition to the id parameter as documented under asynchronous provisioning,
--   you should include a config parameter along with any other optional parameters
--   of your choosing.
--   
--   Name: config
--   Type: object
--   
--   Description:
--   Configuration variables to be set as environment variables on any applications
--   that use this add-on resource. All environment variables that you send should
--   have the same prefix: your add-onâ€™s name, capitalized. However,
--   within the context of a Heroku app, the prefix may be different for a variety
--   of reasons. For example, if your add-on is named fast-db and you are setting
--   FAST_DB_URL, the variable name on the application will default to FAST_DB_URL
--   but would be PRIMARY_DB_URL if the user added the add-on with
--   the prefix PRIMARY_DB.
--   
--   Example:
--   HTTP/1.1 200 OK
--   { "MYADDON_URL": "http://myaddon.com/52e82f5d73" }
--   </pre>
data Provision
Provision :: UserId -> Provision -> [Peer] -> Text -> Provision

-- | User ID
[$sel:id:Provision] :: Provision -> UserId

-- | Heroku env var payload
[$sel:config:Provision] :: Provision -> Provision

-- | IPFS peer list
[$sel:peers:Provision] :: Provision -> [Peer]

-- | A helpful human-readable message
[$sel:message:Provision] :: Provision -> Text
instance GHC.Show.Show Fission.Platform.Heroku.Provision.Types.Provision
instance GHC.Classes.Eq Fission.Platform.Heroku.Provision.Types.Provision
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Platform.Heroku.Provision.Types.Provision
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Platform.Heroku.Provision.Types.Provision
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Platform.Heroku.Provision.Types.Provision
instance Data.Swagger.Internal.Schema.ToSchema Fission.Platform.Heroku.Provision.Types.Provision

module Fission.Platform.Heroku.AddOn.Retriever.Class
class Monad m => Retriever m
getByUUID :: Retriever m => UUID -> m (Maybe (Entity HerokuAddOn))
instance Control.Monad.IO.Class.MonadIO m => Fission.Platform.Heroku.AddOn.Retriever.Class.Retriever (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.Platform.Heroku.AddOn.Retriever

module Fission.Platform.Heroku.AddOn.Destroyer.Class

-- | Destroy <tt>Heroku.AddOn</tt>s
class Monad m => Destroyer m
destroyByUUID :: Destroyer m => UUID -> m ()
instance Control.Monad.IO.Class.MonadIO m => Fission.Platform.Heroku.AddOn.Destroyer.Class.Destroyer (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.Platform.Heroku.AddOn.Destroyer

module Fission.Ownership.Class
class Owned item
ownerId :: Owned item => item -> UserId
instance Fission.Ownership.Class.Owned model => Fission.Ownership.Class.Owned (Database.Persist.Class.PersistEntity.Entity model)
instance Fission.Ownership.Class.Owned (Database.Persist.Class.PersistEntity.Entity Fission.Models.User)
instance Fission.Ownership.Class.Owned Fission.Models.App
instance Fission.Ownership.Class.Owned Fission.Models.Domain
instance Fission.Ownership.Class.Owned Fission.Models.LoosePin

module Fission.Ownership
isOwnedBy :: Owned item => UserId -> item -> Bool

module Fission.LoosePin.Retriever.Class
class Monad m => Retriever m

-- | CIDs associated with a user
getByUserId :: Retriever m => UserId -> m [Entity LoosePin]

-- | Find all CIDs that remain from a list
getByCids :: Retriever m => [CID] -> m [Entity LoosePin]
instance Control.Monad.IO.Class.MonadIO m => Fission.LoosePin.Retriever.Class.Retriever (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.LoosePin.Retriever


-- | Database mutations for <a>LoosePin</a>s
module Fission.LoosePin.Destroyer.Class

-- | Actions for destroying <tt>LoosePin</tt>s
class Monad m => Destroyer m

-- | Destroy a specific <tt>LoosePin</tt>
destroy :: Destroyer m => UserId -> CID -> m ()

-- | Destroy several <tt>LoosePin</tt>s by they primary keys
destroyMany :: Destroyer m => UserId -> [LoosePinId] -> m ()
instance Control.Monad.IO.Class.MonadIO m => Fission.LoosePin.Destroyer.Class.Destroyer (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.LoosePin.Destroyer


-- | Database mutations for <a>LoosePin</a>s
module Fission.LoosePin.Creator.Class

-- | Actions for creating new <tt>LoosePin</tt>s
class Monad m => Creator m

-- | Create a new, timestamped entry
create :: Creator m => UserId -> CID -> UTCTime -> m (Maybe LoosePinId)

-- | Create new <a>LoosePin</a>s, ignoring existing values (set-like)
createMany :: Creator m => UserId -> [CID] -> UTCTime -> m [CID]
instance Control.Monad.IO.Class.MonadIO m => Fission.LoosePin.Creator.Class.Creator (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.LoosePin.Creator

module Fission.LoosePin
type CRUD m = (Retriever m, Creator m, Destroyer m)

module Fission.Internal.Mock.Effect.Types
data RunDB
RunDB :: RunDB
data CheckTime
CheckTime :: CheckTime
data RunAWS
RunAWS :: RunAWS
data UpdateRoute53
UpdateRoute53 :: UpdateRoute53
data ClearRoute53
ClearRoute53 :: ClearRoute53
data SetDNSLink
SetDNSLink :: SetDNSLink
data FollowDNSLink
FollowDNSLink :: URL -> Path URL -> FollowDNSLink
data RunLocalIPFS
RunLocalIPFS :: RunLocalIPFS
data RunRemoteIPFS
RemoteIPFSGeneric :: RunRemoteIPFS
RemoteIPFSAdd :: ByteString -> RunRemoteIPFS
RemoteIPFSCat :: CID -> RunRemoteIPFS
RemoteIPFSPin :: CID -> RunRemoteIPFS
RemoteIPFSUnpin :: CID -> Bool -> RunRemoteIPFS
data LogMsg
LogMsg :: LogLevel -> LogStr -> LogMsg
data CreateHerokuAddOn
CreateHerokuAddOn :: UUID -> CreateHerokuAddOn
data DestroyHerokuAddOn
DestroyHerokuAddOn :: UUID -> DestroyHerokuAddOn
data RetrieveUser
GetUserByUsername :: Username -> RetrieveUser
GetUserByPublicKey :: Public -> RetrieveUser
GetUserByHerokuAddOnId :: HerokuAddOnId -> RetrieveUser
GetUserByEmail :: Email -> RetrieveUser
GetUserById :: UserId -> RetrieveUser
data CreateUser
CreateUser :: CreateUser
data ModifyUser
ModifyUser :: UserId -> ModifyUser
data DestroyUser
DestroyUser :: UserId -> DestroyUser
data RetrieveLoosePin
GetLoosePinByUserId :: UserId -> RetrieveLoosePin
GetLoosePinByCID :: CID -> RetrieveLoosePin
data CreateLoosePin
CreateLoosePin :: UserId -> CID -> CreateLoosePin
data DestroyLoosePin
DestroyLoosePin :: UserId -> CID -> DestroyLoosePin
DestroyLoosePinById :: UserId -> LoosePinId -> DestroyLoosePin
type FissionEffs = '[CheckTime, RunAWS, RunDB, SetDNSLink, FollowDNSLink, UpdateRoute53, ClearRoute53, RunLocalIPFS, RunRemoteIPFS, LogMsg, DestroyHerokuAddOn, DestroyUser, DestroyLoosePin, RetrieveUser, RetrieveLoosePin, ModifyUser, CreateUser, CreateLoosePin, CreateHerokuAddOn]
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.DestroyLoosePin
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.DestroyLoosePin
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.CreateLoosePin
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.CreateLoosePin
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.RetrieveLoosePin
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.RetrieveLoosePin
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.DestroyUser
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.DestroyUser
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.ModifyUser
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.ModifyUser
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.CreateUser
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.CreateUser
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.RetrieveUser
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.RetrieveUser
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.CreateHerokuAddOn
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.CreateHerokuAddOn
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.DestroyHerokuAddOn
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.DestroyHerokuAddOn
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.LogMsg
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.LogMsg
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.RunRemoteIPFS
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.RunRemoteIPFS
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.RunLocalIPFS
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.RunLocalIPFS
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.FollowDNSLink
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.FollowDNSLink
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.SetDNSLink
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.SetDNSLink
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.ClearRoute53
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.ClearRoute53
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.UpdateRoute53
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.UpdateRoute53
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.RunAWS
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.RunAWS
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.CheckTime
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.CheckTime
instance GHC.Show.Show Fission.Internal.Mock.Effect.Types.RunDB
instance GHC.Classes.Eq Fission.Internal.Mock.Effect.Types.RunDB

module Fission.Internal.Mock.Effect
log :: (IsMember eff log, Applicative t, MonadWriter (t (OpenUnion log)) m) => eff -> m ()

module Fission.Internal.Fixture.User
user :: User

module Fission.Internal.Fixture

module Fission.Error.AlreadyExists.Types
data AlreadyExists entity
AlreadyExists :: AlreadyExists entity
instance Data.Typeable.Internal.Typeable entity => GHC.Exception.Type.Exception (Fission.Error.AlreadyExists.Types.AlreadyExists entity)
instance GHC.Classes.Eq (Fission.Error.AlreadyExists.Types.AlreadyExists entity)
instance GHC.Show.Show (Fission.Error.AlreadyExists.Types.AlreadyExists entity)
instance RIO.Prelude.Display.Display (Fission.Error.AlreadyExists.Types.AlreadyExists entity) => Fission.Web.Error.Class.ToServerError (Fission.Error.AlreadyExists.Types.AlreadyExists entity)
instance RIO.Prelude.Display.Display (Fission.Error.AlreadyExists.Types.AlreadyExists Fission.Models.User)
instance RIO.Prelude.Display.Display (Fission.Error.AlreadyExists.Types.AlreadyExists Fission.Models.UserChallenge)
instance RIO.Prelude.Display.Display (Fission.Error.AlreadyExists.Types.AlreadyExists Fission.Models.LoosePin)
instance RIO.Prelude.Display.Display (Fission.Error.AlreadyExists.Types.AlreadyExists Fission.Models.Domain)
instance RIO.Prelude.Display.Display (Fission.Error.AlreadyExists.Types.AlreadyExists Fission.Models.App)
instance RIO.Prelude.Display.Display (Fission.Error.AlreadyExists.Types.AlreadyExists Fission.Models.HerokuAddOn)

module Fission.Domain.Creator.Class

-- | Domain registration / creation
class Monad m => Creator m

-- | Register a new domain name
create :: Creator m => DomainName -> UserId -> ZoneID -> UTCTime -> m ()
instance Control.Monad.IO.Class.MonadIO m => Fission.Domain.Creator.Class.Creator (Fission.Internal.MonadDB.Types.Transaction m)


-- | Fission authorization
module Fission.Authorization.Types

-- | The final high-level authorization -- internal use only
data Authorization
Authorization :: !Either Heroku DID -> !Entity User -> !Potency -> !Scope Resource -> Authorization
[$sel:sender:Authorization] :: Authorization -> !Either Heroku DID
[$sel:about:Authorization] :: Authorization -> !Entity User
[$sel:potency:Authorization] :: Authorization -> !Potency
[$sel:resource:Authorization] :: Authorization -> !Scope Resource
data Heroku
Heroku :: Heroku
instance GHC.Classes.Eq Fission.Authorization.Types.Authorization
instance GHC.Show.Show Fission.Authorization.Types.Authorization
instance GHC.Classes.Eq Fission.Authorization.Types.Heroku
instance GHC.Show.Show Fission.Authorization.Types.Heroku
instance RIO.Prelude.Display.Display Fission.Authorization.Types.Authorization

module Fission.Authorization
latestVersion :: SemVer

module Fission.Web.Client.JWT
mkAuthReq :: (MonadIO m, MonadTime m, ServerDID m, MonadWebAuth m SecretKey) => m (Request -> Request)
ucan :: UTCTime -> DID -> SecretKey -> Proof -> JWT

module Fission.Web.Client
sendRequestM :: MonadWebClient m => m (ClientM a) -> m (Either ClientError a)
withPayload :: Functor f => f (a -> b) -> a -> f b
infixl 1 `withPayload`
authClient :: (MonadIO m, MonadTime m, MonadLogger m, ServerDID m, MonadWebAuth m (AuthClientData a), MonadWebAuth m SecretKey, HasClient ClientM api, Client ClientM api ~ (AuthenticatedRequest a -> f b)) => Proxy api -> m (f b)

module Fission.CLI.Environment.Override.Types

-- | This is the part that actually gets written to disk.
--   <tt>Environment</tt> is constructed virtually from layers of
--   <a>Override</a>s.
data Override
Override :: ![Peer] -> !Maybe URL -> !Maybe BasicAuthData -> !Maybe Ignored -> !Maybe FilePath -> !Maybe DID -> Override
[$sel:peers:Override] :: Override -> ![Peer]
[$sel:maybeAppURL:Override] :: Override -> !Maybe URL
[$sel:maybeUserAuth:Override] :: Override -> !Maybe BasicAuthData
[$sel:maybeIgnored:Override] :: Override -> !Maybe Ignored
[$sel:maybeBuildDir:Override] :: Override -> !Maybe FilePath
[$sel:maybeServerDID:Override] :: Override -> !Maybe DID
instance GHC.Base.Semigroup Fission.CLI.Environment.Override.Types.Override
instance GHC.Base.Monoid Fission.CLI.Environment.Override.Types.Override
instance Data.Aeson.Types.ToJSON.ToJSON Fission.CLI.Environment.Override.Types.Override
instance Data.Aeson.Types.FromJSON.FromJSON Fission.CLI.Environment.Override.Types.Override

module Fission.CLI.Environment.Override

-- | Gets hierarchical environment by recursed through file system
get :: MonadIO m => m Override

-- | Recurses up to user root to find an env with basic auth data
findBasicAuth :: MonadIO m => m (Maybe BasicAuthData)

-- | Recurses up to user root to find a env that satisfies the
--   <tt>finder</tt> predicate
findRecurse :: MonadIO m => (Override -> Bool) -> FilePath -> m (Maybe (FilePath, Override))

-- | Decodes file to partial environment
decode :: MonadIO m => FilePath -> m Override

-- | Writes partial environment to path
write :: MonadIO m => FilePath -> Override -> m ()

-- | Merge a partial env with an existing env at the path
writeMerge :: MonadIO m => FilePath -> Override -> m ()

-- | globalEnv environment in users home
globalEnv :: MonadIO m => m FilePath
toFull :: Override -> Environment
fromFull :: Environment -> Override

-- | Deletes user_auth from env at ~/.fission.yaml
deleteHomeAuth :: MonadIO m => m ()

module Fission.CLI.Prompt.BuildDir

-- | Checks user's current build dir by: * recursively checking
--   .fission.yaml * guessing a build dir from common static site
--   generators * prompting the user with that build dir
checkBuildDir :: (MonadIO m, MonadLogger m) => FilePath -> m FilePath

-- | Check path to see if a possible build folder exists there
guessBuildDir :: MonadIO m => FilePath -> m (Maybe FilePath)


-- | File sync, IPFS-style
module Fission.CLI.Display.Error

-- | Display a given error to the user and log an error to the debug log.
put :: (MonadIO m, MonadLogger m, Show err) => err -> Text -> m ()

-- | Display a generic error message to the user and log an error to the
--   debug log.
put' :: (MonadIO m, MonadLogger m, Show err) => err -> m ()
putErrOr :: (MonadIO m, MonadLogger m, Show err) => (t -> m ()) -> Either err t -> m ()

-- | Display an error message to a user encouraging them to run `fission
--   setup` Error depends on if they have basic auth saved somewhere (ie if
--   they are an existing user)
notConnected :: (MonadIO m, MonadLogger m, Exception err) => err -> m ()

module Fission.CLI.Prompt.Fields

-- | Prompt a user for a value and do not accept an empty value
getRequired :: (MonadIO m, MonadLogger m) => ByteString -> m ByteString

-- | Prompt a user for a secret and do not accept an empty value
getRequiredSecret :: (MonadIO m, MonadLogger m) => ByteString -> m ByteString


-- | Success messages and conditions
module Fission.CLI.Display.Success
live :: MonadIO m => CID -> m ()
putOk :: MonadIO m => Text -> m ()
dnsUpdated :: MonadIO m => URL -> m ()
currentlyLoggedInAs :: MonadIO m => Text -> m ()
alreadyLoggedInAs :: MonadIO m => Text -> m ()


-- | Grab files directly from IPFS
module Fission.CLI.Command.Down

-- | The command to attach to the CLI tree
cmd :: (MonadUnliftIO m, MonadLocalIPFS m, MonadLogger m) => Command m CID ()
($sel:handler:Command) :: Command m input output -> input -> m output

module Fission.AWS.Route53.Class

-- | Low-level Route53 interface / no auth checks do not use directly
class MonadAWS m => MonadRoute53 m
set :: MonadRoute53 m => RecordType -> URL -> ZoneID -> NonEmpty Text -> Natural -> m (Either ServerError ChangeResourceRecordSetsResponse)
clear :: MonadRoute53 m => RecordType -> URL -> ZoneID -> m (Either ServerError ChangeResourceRecordSetsResponse)

module Fission.AWS.Route53

module Fission.AWS
validate :: ChangeResourceRecordSetsResponse -> Either ServerError ChangeResourceRecordSetsResponse

module Fission.Error.NotFound.Types
data NotFound entity
NotFound :: NotFound entity
instance Data.Typeable.Internal.Typeable entity => GHC.Exception.Type.Exception (Fission.Error.NotFound.Types.NotFound entity)
instance GHC.Classes.Eq (Fission.Error.NotFound.Types.NotFound entity)
instance GHC.Show.Show (Fission.Error.NotFound.Types.NotFound entity)
instance Fission.Web.Error.Class.ToServerError (Fission.Error.NotFound.Types.NotFound entity)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.Models.User)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.Models.UserChallenge)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.Models.LoosePin)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.Models.Domain)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.URL.Types.URL)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.Models.App)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.Models.AppDomain)
instance RIO.Prelude.Display.Display (Fission.Error.NotFound.Types.NotFound Fission.AWS.Zone.Types.ZoneID)

module Fission.Error.ActionNotAuthorized.Types
data ActionNotAuthorized entity
ActionNotAuthorized :: UserId -> ActionNotAuthorized entity
instance Data.Typeable.Internal.Typeable entity => GHC.Exception.Type.Exception (Fission.Error.ActionNotAuthorized.Types.ActionNotAuthorized entity)
instance GHC.Classes.Eq (Fission.Error.ActionNotAuthorized.Types.ActionNotAuthorized entity)
instance GHC.Show.Show (Fission.Error.ActionNotAuthorized.Types.ActionNotAuthorized entity)
instance RIO.Prelude.Display.Display (Fission.Error.ActionNotAuthorized.Types.ActionNotAuthorized entity)
instance Fission.Web.Error.Class.ToServerError (Fission.Error.ActionNotAuthorized.Types.ActionNotAuthorized entity)

module Fission.Error.Types

module Fission.Platform.Heroku.AddOn.Creator.Class
class Monad m => Creator m
create :: Creator m => UUID -> Region -> UTCTime -> m (Either (AlreadyExists HerokuAddOn) HerokuAddOnId)
instance Control.Monad.IO.Class.MonadIO m => Fission.Platform.Heroku.AddOn.Creator.Class.Creator (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.Platform.Heroku.AddOn.Creator

module Fission.Platform.Heroku.AddOn
type CRUD m = (Creator m, Destroyer m, Retriever m)

module Fission.IPFS.DNSLink.Class

-- | Low-level <tt>DNSLink</tt> interface
class MonadRoute53 m => MonadDNSLink m
set :: MonadDNSLink m => UserId -> URL -> ZoneID -> CID -> m (Either Errors URL)
follow :: MonadDNSLink m => UserId -> URL -> ZoneID -> Path URL -> m (Either Errors ())
type Errors = OpenUnion '[ServerError, InvalidURL, NotFound URL, ActionNotAuthorized URL]

module Fission.Internal.Mock.Config.Types
data Config
Config :: (DomainName -> Maybe Subdomain -> CID -> Either Errors URL) -> (URL -> Path URL -> Either Errors ()) -> DomainName -> (RecordType -> URL -> ZoneID -> NonEmpty Text -> Natural -> Either ServerError ChangeResourceRecordSetsResponse) -> (RecordType -> URL -> Either ServerError ChangeResourceRecordSetsResponse) -> UTCTime -> NonEmpty Peer -> AuthHandler Request (Entity User) -> AuthHandler Request DID -> AuthHandler Request Authorization -> BasicAuthCheck Auth -> Bool -> Either Error RawMessage -> Either ClientError CID -> Either ClientError Serialized -> Either ClientError Response -> Either ClientError Response -> Config
[$sel:setDNSLink:Config] :: Config -> DomainName -> Maybe Subdomain -> CID -> Either Errors URL
[$sel:followDNSLink:Config] :: Config -> URL -> Path URL -> Either Errors ()
[$sel:getBaseDomain:Config] :: Config -> DomainName
[$sel:updateRoute53:Config] :: Config -> RecordType -> URL -> ZoneID -> NonEmpty Text -> Natural -> Either ServerError ChangeResourceRecordSetsResponse
[$sel:clearRoute53:Config] :: Config -> RecordType -> URL -> Either ServerError ChangeResourceRecordSetsResponse
[$sel:now:Config] :: Config -> UTCTime
[$sel:linkedPeers:Config] :: Config -> NonEmpty Peer
[$sel:userVerifier:Config] :: Config -> AuthHandler Request (Entity User)
[$sel:didVerifier:Config] :: Config -> AuthHandler Request DID
[$sel:authVerifier:Config] :: Config -> AuthHandler Request Authorization
[$sel:herokuVerifier:Config] :: Config -> BasicAuthCheck Auth
[$sel:forceAuthed:Config] :: Config -> Bool
[$sel:localIPFSCall:Config] :: Config -> Either Error RawMessage
[$sel:remoteIPFSAdd:Config] :: Config -> Either ClientError CID
[$sel:remoteIPFSCat:Config] :: Config -> Either ClientError Serialized
[$sel:remoteIPFSPin:Config] :: Config -> Either ClientError Response
[$sel:remoteIPFSUnpin:Config] :: Config -> Either ClientError Response

module Fission.Internal.Mock.Config
defaultConfig :: Config

module Fission.IPFS.DNSLink

module Fission.Error
openLeft :: IsMember err errs => err -> Either (OpenUnion errs) a
relaxedLeft :: Contains errsA errsB => OpenUnion errsA -> Either (OpenUnion errsB) a
fromMaybe :: IsMember err errs => err -> (a -> b) -> Maybe a -> Either (OpenUnion errs) b
fromMaybe' :: IsMember err errs => err -> Maybe a -> Either (OpenUnion errs) a
retryOnErr :: Monad m => (a -> m Bool) -> Natural -> m a -> m a

module Fission.Web.Client.Error
retryOnStatus :: (MonadWebClient m, MonadLogger m) => [Status] -> Natural -> ClientM a -> m (Either ClientError a)
checkStatus :: MonadLogger m => [Status] -> Either ClientError a -> m Bool

module Fission.User.Modifier.Class
class Monad m => Modifier m
updatePassword :: Modifier m => UserId -> Password -> UTCTime -> m (Either FailedDigest Password)
updatePublicKey :: Modifier m => UserId -> Public -> UTCTime -> m (Either Errors Public)
addExchangeKey :: Modifier m => UserId -> PublicKey -> UTCTime -> m (Either Errors [PublicKey])
removeExchangeKey :: Modifier m => UserId -> PublicKey -> UTCTime -> m (Either Errors [PublicKey])
setData :: Modifier m => UserId -> CID -> UTCTime -> m (Either Errors ())
type Errors = OpenUnion '[NotFound User, NotFound URL, ActionNotAuthorized URL, Error, Error, ServerError, InvalidURL]

module Fission.User.Modifier
updatePasswordDB :: MonadIO m => UserId -> SecretDigest -> UTCTime -> Transaction m ()
updatePublicKeyDB :: MonadIO m => UserId -> Public -> UTCTime -> Transaction m (Either Errors Public)
addExchangeKeyDB :: MonadIO m => UserId -> PublicKey -> UTCTime -> Transaction m (Either Errors [PublicKey])
removeExchangeKeyDB :: MonadIO m => UserId -> PublicKey -> UTCTime -> Transaction m (Either Errors [PublicKey])
setDataDB :: MonadIO m => UserId -> CID -> Bytes -> UTCTime -> Transaction m ()

module Fission.Web.DNS
type API = Summary "Set account's DNSLink" :> Description "DEPRECATED \9940 Set account's DNSLink to a CID" :> Capture "cid" CID :> PutAccepted '[PlainText, OctetStream] DomainName
server :: (MonadTime m, MonadThrow m, MonadLogger m, Modifier m) => Authorization -> ServerT API m

module Fission.User.Destroyer.Class

-- | Destroy <tt>User</tt>s
class Monad m => Destroyer m
deactivate :: Destroyer m => UserId -> UserId -> m (Either (ActionNotAuthorized User) ())
instance Control.Monad.IO.Class.MonadIO m => Fission.User.Destroyer.Class.Destroyer (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.User.Destroyer

module Fission.Domain.Retriever.Class
class Monad m => Retriever m
getByDomainName :: Retriever m => DomainName -> m (Either (NotFound Domain) Domain)
instance Control.Monad.IO.Class.MonadIO m => Fission.Domain.Retriever.Class.Retriever (Fission.Internal.MonadDB.Types.Transaction m)


-- | DNS / Domain actions
module Fission.Domain

module Fission.Challenge.Verifier.Class
class Monad m => Verifier m
verify :: Verifier m => Challenge -> m (Either (NotFound UserChallenge) ())
instance Control.Monad.IO.Class.MonadIO m => Fission.Challenge.Verifier.Class.Verifier (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Retriever.Class
class Monad m => Retriever m
byId :: Retriever m => UserId -> AppId -> m (Either Errors (Entity App))
byURL :: Retriever m => UserId -> URL -> m (Either Errors (Entity App))
ownedBy :: Retriever m => UserId -> m [Entity App]
instance Control.Monad.IO.Class.MonadIO m => Fission.App.Retriever.Class.Retriever (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Retriever

module Fission.App.Modifier.Class
class Monad m => Modifier m
setCID :: Modifier m => UserId -> URL -> CID -> Bool -> UTCTime -> m (Either Errors AppId)
type Errors = OpenUnion '[NotFound App, NotFound AppDomain, NotFound Domain, NotFound URL, ActionNotAuthorized App, ActionNotAuthorized AppDomain, ActionNotAuthorized URL, Error, Error, ServerError, InvalidURL]

module Fission.App.Modifier
setCidDB :: MonadIO m => UserId -> URL -> CID -> Bytes -> Bool -> UTCTime -> Transaction m (Either Errors AppId)

module Fission.App.Domain.Retriever.Class
class Monad m => Retriever m
allForOwner :: Retriever m => UserId -> m [Entity AppDomain]
allForApp :: Retriever m => AppId -> m [Entity AppDomain]
allSiblingsByDomain :: Retriever m => DomainName -> Maybe Subdomain -> m (Either Errors [Entity AppDomain])
primarySibling :: Retriever m => UserId -> URL -> m (Either Errors (Entity AppDomain))
type Errors = OpenUnion '[NotFound AppDomain, ActionNotAuthorized AppDomain, NotFound App, ActionNotAuthorized App]
instance Control.Monad.IO.Class.MonadIO m => Fission.App.Domain.Retriever.Class.Retriever (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Domain.Retriever

module Fission.App.Destroyer.Class
class Monad m => Destroyer m
destroy :: Destroyer m => UserId -> AppId -> UTCTime -> m (Either Errors [URL])
destroyByURL :: Destroyer m => UserId -> DomainName -> Maybe Subdomain -> UTCTime -> m (Either Errors [URL])
type Errors = OpenUnion '[NotFound App, ActionNotAuthorized App, NotFound AppDomain, ActionNotAuthorized AppDomain, NotFound ZoneID, ServerError]
instance Control.Monad.IO.Class.MonadIO m => Fission.App.Destroyer.Class.Destroyer (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.Web.App.Destroy
type API = ByURLAPI :<|> ByIdAPI
type ByURLAPI = Summary "Destroy app by URL" :> Description "Destroy app by any associated URL" :> "associated" :> Capture "url" URL :> DeleteNoContent '[JSON] NoContent
type ByIdAPI = Summary "Destroy app by ID" :> Description "Destroy app by its ID" :> Capture "appId" AppId :> DeleteNoContent '[JSON] NoContent
server :: (MonadTime m, MonadThrow m, MonadLogger m, Destroyer m) => Authorization -> ServerT API m
destroyById :: (MonadTime m, MonadThrow m, MonadLogger m, Destroyer m) => Authorization -> ServerT ByIdAPI m
destroyByURL :: (MonadTime m, MonadThrow m, MonadLogger m, Destroyer m) => Authorization -> ServerT ByURLAPI m

module Fission.App.Destroyer

module Fission.Challenge.Creator.Class
class Monad m => Creator m
create :: Creator m => UserId -> m (Either (AlreadyExists UserChallenge) Challenge)
instance Control.Monad.IO.Class.MonadIO m => Fission.Challenge.Creator.Class.Creator (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Domain.Error
data NotRegisteredToApp
NotRegisteredToApp :: AppId -> DomainName -> Maybe Subdomain -> NotRegisteredToApp
data AlreadyAssociated
AlreadyAssociated :: AppId -> DomainName -> Maybe Subdomain -> AlreadyAssociated
[$sel:appId:AlreadyAssociated] :: AlreadyAssociated -> AppId
[$sel:domainName:AlreadyAssociated] :: AlreadyAssociated -> DomainName
[$sel:maybeSubdomain:AlreadyAssociated] :: AlreadyAssociated -> Maybe Subdomain
instance GHC.Exception.Type.Exception Fission.App.Domain.Error.AlreadyAssociated
instance GHC.Classes.Eq Fission.App.Domain.Error.AlreadyAssociated
instance GHC.Show.Show Fission.App.Domain.Error.AlreadyAssociated
instance GHC.Classes.Eq Fission.App.Domain.Error.NotRegisteredToApp
instance GHC.Show.Show Fission.App.Domain.Error.NotRegisteredToApp
instance Fission.Web.Error.Class.ToServerError Fission.App.Domain.Error.AlreadyAssociated
instance RIO.Prelude.Display.Display Fission.App.Domain.Error.AlreadyAssociated

module Fission.App.Domain.Dissociator.Class
class Monad m => Dissociator m
dissociate :: Dissociator m => UserId -> AppId -> DomainName -> Maybe Subdomain -> UTCTime -> m (Either Errors ())
type Errors = OpenUnion '[NotRegisteredToApp, ActionNotAuthorized App, NotFound App]
instance Control.Monad.IO.Class.MonadIO m => Fission.App.Domain.Dissociator.Class.Dissociator (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Domain.Dissociator

module Fission.App.Domain.Associator.Class
class Monad m => Associator m
associate :: Associator m => UserId -> AppId -> Checkmark -> DomainName -> Maybe Subdomain -> UTCTime -> m (Either Errors ())
type Errors = OpenUnion '[AlreadyAssociated, ActionNotAuthorized App, NotFound App]
instance Control.Monad.IO.Class.MonadIO m => Fission.App.Domain.Associator.Class.Associator (Fission.Internal.MonadDB.Types.Transaction m)

module Fission.App.Domain.Associator
associateDefault :: (MonadIO m, Associator m, Initializer m) => UserId -> AppId -> UTCTime -> m (Either Errors Subdomain)

module Fission.App.Domain
class Monad m => Dissociator m
dissociate :: Dissociator m => UserId -> AppId -> DomainName -> Maybe Subdomain -> UTCTime -> m (Either Errors ())
class Monad m => Retriever m
allForOwner :: Retriever m => UserId -> m [Entity AppDomain]
allForApp :: Retriever m => AppId -> m [Entity AppDomain]
allSiblingsByDomain :: Retriever m => DomainName -> Maybe Subdomain -> m (Either Errors [Entity AppDomain])
primarySibling :: Retriever m => UserId -> URL -> m (Either Errors (Entity AppDomain))
type Actions m = (Initializer m, Associator m, Dissociator m, Retriever m)

module Fission.User.Creator.Class
class Creator m => Creator m

-- | Create a new, timestamped entry
create :: Creator m => Username -> Public -> Email -> UTCTime -> m (Either Errors UserId)
createWithPassword :: Creator m => Username -> Password -> Email -> UTCTime -> m (Either Errors UserId)

-- | Create a new, timestamped entry and heroku add-on
createWithHeroku :: Creator m => UUID -> Region -> Username -> Password -> UTCTime -> m (Either Errors UserId)
type Errors = OpenUnion '[ActionNotAuthorized App, NotFound App, ActionNotAuthorized URL, NotFound URL, AlreadyExists HerokuAddOn, AlreadyAssociated, AlreadyExists, NotFound User, Invalid, FailedDigest, Error, Error, InvalidURL, ServerError]

module Fission.User.Creator
createDB :: MonadIO m => Username -> Public -> Email -> UTCTime -> Transaction m (Either Errors UserId)
createWithPasswordDB :: MonadIO m => Username -> Password -> Email -> UTCTime -> Transaction m (Either Errors UserId)
createWithHerokuDB :: MonadIO m => UUID -> Region -> Username -> Password -> UTCTime -> Transaction m (Either Errors UserId)

module Fission.User
data AlreadyExists
ConflictingUsername :: Username -> AlreadyExists
ConflictingPublicKey :: Public -> AlreadyExists
class Creator m => Creator m

-- | Create a new, timestamped entry
create :: Creator m => Username -> Public -> Email -> UTCTime -> m (Either Errors UserId)
createWithPassword :: Creator m => Username -> Password -> Email -> UTCTime -> m (Either Errors UserId)

-- | Create a new, timestamped entry and heroku add-on
createWithHeroku :: Creator m => UUID -> Region -> Username -> Password -> UTCTime -> m (Either Errors UserId)
createDB :: MonadIO m => Username -> Public -> Email -> UTCTime -> Transaction m (Either Errors UserId)
createWithPasswordDB :: MonadIO m => Username -> Password -> Email -> UTCTime -> Transaction m (Either Errors UserId)
createWithHerokuDB :: MonadIO m => UUID -> Region -> Username -> Password -> UTCTime -> Transaction m (Either Errors UserId)
class Monad m => Modifier m
updatePassword :: Modifier m => UserId -> Password -> UTCTime -> m (Either FailedDigest Password)
updatePublicKey :: Modifier m => UserId -> Public -> UTCTime -> m (Either Errors Public)
addExchangeKey :: Modifier m => UserId -> PublicKey -> UTCTime -> m (Either Errors [PublicKey])
removeExchangeKey :: Modifier m => UserId -> PublicKey -> UTCTime -> m (Either Errors [PublicKey])
setData :: Modifier m => UserId -> CID -> UTCTime -> m (Either Errors ())
updatePasswordDB :: MonadIO m => UserId -> SecretDigest -> UTCTime -> Transaction m ()
updatePublicKeyDB :: MonadIO m => UserId -> Public -> UTCTime -> Transaction m (Either Errors Public)
addExchangeKeyDB :: MonadIO m => UserId -> PublicKey -> UTCTime -> Transaction m (Either Errors [PublicKey])
removeExchangeKeyDB :: MonadIO m => UserId -> PublicKey -> UTCTime -> Transaction m (Either Errors [PublicKey])
setDataDB :: MonadIO m => UserId -> CID -> Bytes -> UTCTime -> Transaction m ()
type CRUD m = (Retriever m, Creator m, Modifier m, Destroyer m)

module Fission.Web.Auth.Token.JWT.Validation
check :: (Resolver m, ServerDID m, MonadTime m) => RawContent -> JWT -> m (Either Error JWT)
check' :: (ServerDID m, Resolver m) => RawContent -> JWT -> UTCTime -> m (Either Error JWT)
pureChecks :: RawContent -> JWT -> Either Error JWT
checkTime :: UTCTime -> JWT -> Either Error JWT
checkSignature :: RawContent -> JWT -> Either Error JWT
checkEd25519Signature :: RawContent -> JWT -> Either Error JWT
checkRSA2048Signature :: RawContent -> JWT -> Signature -> Either Error JWT

module Fission.Web.Auth.Token.UCAN

-- | Auth handler for delegated auth Ensures properly formatted token *and
--   does check against DB*
handler :: (MonadLogger m, MonadThrow m, Resolver m, ServerDID m, MonadTime m, MonadDB t m, Retriever t) => Token -> m Authorization

module Fission.Web.Auth.Token.Basic
handler :: (MonadIO m, MonadLogger m, MonadThrow m, MonadDB t m, Retriever t) => Token -> m Authorization
checkUser :: (MonadLogger m, MonadDB t m, Retriever t) => BasicAuthData -> m (Either Error Authorization)
parseBasic :: Token -> Either Error BasicAuthData

module Fission.Web.Auth.Token
get :: Request -> Either Error Token

-- | Higher order auth handler Uses basic auth for <a>Basic</a> tokens Uses
--   our custom JWT auth for <a>Bearer</a> tokens
handler :: (Resolver m, ServerDID m, MonadLogger m, MonadThrow m, MonadTime m, MonadDB t m, Retriever t) => Request -> m Authorization


-- | Authorization types; primarily more semantic aliases
module Fission.Web.Auth.Types

-- | Authorization check for the Heroku Addon API
type HerokuAddOnAPI = BasicAuth "heroku add-on api" Auth

-- | Authorization check to return encoded DID for registering new users
type RegisterDID = AuthProtect "register-did"

-- | Higher order auth that encompasses Basic &amp; JWT auth
type HigherOrder = AuthProtect "higher-order"

module Fission.Web.Auth
type Checks = '[AuthHandler Request DID, AuthHandler Request Authorization, BasicAuthCheck Auth]
authWithContext :: HasServer api Checks => Proxy api -> (forall a. m a -> Handler a) -> ServerT api m -> ServerT api Handler

-- | Basic auth. Used for Heroku auth check
basic :: ByteString -> ByteString -> BasicAuthCheck ByteString

-- | Construct an authorization context
mkAuth :: (MonadAuth DID m, MonadAuth Authorization m, MonadBasicAuth Auth m) => m (Context Checks)

module Fission.Web.Auth.DID

-- | Auth handler for registering DIDs Ensures properly formatted token but
--   *does not check against DB*
handler :: (Resolver m, ServerDID m, MonadLogger m, MonadThrow m, MonadTime m) => Request -> m DID

module Fission.CLI.Config.Connected.Types
data ConnectedConfig
ConnectedConfig :: !Manager -> !SecretKey -> !DID -> !DID -> !BaseUrl -> !LogFunc -> !ProcessContext -> !BinPath -> !Timeout -> !Peer -> !Ignored -> ConnectedConfig
[$sel:httpManager:ConnectedConfig] :: ConnectedConfig -> !Manager
[$sel:secretKey:ConnectedConfig] :: ConnectedConfig -> !SecretKey
[$sel:cliDID:ConnectedConfig] :: ConnectedConfig -> !DID
[$sel:serverDID:ConnectedConfig] :: ConnectedConfig -> !DID
[$sel:fissionURL:ConnectedConfig] :: ConnectedConfig -> !BaseUrl
[$sel:logFunc:ConnectedConfig] :: ConnectedConfig -> !LogFunc
[$sel:processCtx:ConnectedConfig] :: ConnectedConfig -> !ProcessContext
[$sel:ipfsPath:ConnectedConfig] :: ConnectedConfig -> !BinPath
[$sel:ipfsTimeout:ConnectedConfig] :: ConnectedConfig -> !Timeout
[$sel:peer:ConnectedConfig] :: ConnectedConfig -> !Peer
[$sel:ignoredFiles:ConnectedConfig] :: ConnectedConfig -> !Ignored

-- | The top-level app type
newtype FissionConnected a
FissionConnected :: RIO ConnectedConfig a -> FissionConnected a
[$sel:unwrapFissionConnected:FissionConnected] :: FissionConnected a -> RIO ConnectedConfig a
instance Control.Monad.Catch.MonadCatch Fission.CLI.Config.Connected.Types.FissionConnected
instance Control.Monad.Catch.MonadThrow Fission.CLI.Config.Connected.Types.FissionConnected
instance Control.Monad.Reader.Class.MonadReader Fission.CLI.Config.Connected.Types.ConnectedConfig Fission.CLI.Config.Connected.Types.FissionConnected
instance Control.Monad.IO.Unlift.MonadUnliftIO Fission.CLI.Config.Connected.Types.FissionConnected
instance Control.Monad.IO.Class.MonadIO Fission.CLI.Config.Connected.Types.FissionConnected
instance GHC.Base.Monad Fission.CLI.Config.Connected.Types.FissionConnected
instance GHC.Base.Applicative Fission.CLI.Config.Connected.Types.FissionConnected
instance GHC.Base.Functor Fission.CLI.Config.Connected.Types.FissionConnected
instance Control.Monad.Logger.MonadLogger Fission.CLI.Config.Connected.Types.FissionConnected
instance Network.IPFS.Local.Class.MonadLocalIPFS Fission.CLI.Config.Connected.Types.FissionConnected
instance Fission.CLI.Environment.Class.MonadEnvironment Fission.CLI.Config.Connected.Types.FissionConnected
instance Fission.Web.Client.Class.MonadWebClient Fission.CLI.Config.Connected.Types.FissionConnected
instance Fission.Web.Client.Auth.Class.MonadWebAuth Fission.CLI.Config.Connected.Types.FissionConnected Fission.User.DID.Types.DID
instance Control.Monad.Time.MonadTime Fission.CLI.Config.Connected.Types.FissionConnected
instance Fission.Web.Client.Auth.Class.MonadWebAuth Fission.CLI.Config.Connected.Types.FissionConnected Fission.Web.Auth.Token.Types.Token
instance Fission.Web.Client.Auth.Class.MonadWebAuth Fission.CLI.Config.Connected.Types.FissionConnected Crypto.PubKey.Ed25519.SecretKey
instance Fission.Authorization.ServerDID.Class.ServerDID Fission.CLI.Config.Connected.Types.FissionConnected
instance RIO.Process.HasProcessContext Fission.CLI.Config.Connected.Types.ConnectedConfig
instance RIO.Prelude.Logger.HasLogFunc Fission.CLI.Config.Connected.Types.ConnectedConfig


-- | General configuration required to run any CLI function
module Fission.CLI.Config.Base.Types

-- | The configuration used for the CLI application
data BaseConfig
BaseConfig :: !Manager -> !BaseUrl -> !Maybe DID -> !LogFunc -> !ProcessContext -> !BinPath -> !Timeout -> BaseConfig
[$sel:httpManager:BaseConfig] :: BaseConfig -> !Manager
[$sel:fissionURL:BaseConfig] :: BaseConfig -> !BaseUrl

-- | Typically from setting with envar
[$sel:cachedServerDID:BaseConfig] :: BaseConfig -> !Maybe DID
[$sel:logFunc:BaseConfig] :: BaseConfig -> !LogFunc
[$sel:processCtx:BaseConfig] :: BaseConfig -> !ProcessContext
[$sel:ipfsPath:BaseConfig] :: BaseConfig -> !BinPath
[$sel:ipfsTimeout:BaseConfig] :: BaseConfig -> !Timeout

-- | The top-level app type
newtype FissionBase a
FissionBase :: RIO BaseConfig a -> FissionBase a
[$sel:unwrapFissionBase:FissionBase] :: FissionBase a -> RIO BaseConfig a
instance Control.Monad.Catch.MonadThrow Fission.CLI.Config.Base.Types.FissionBase
instance Control.Monad.Reader.Class.MonadReader Fission.CLI.Config.Base.Types.BaseConfig Fission.CLI.Config.Base.Types.FissionBase
instance Control.Monad.IO.Unlift.MonadUnliftIO Fission.CLI.Config.Base.Types.FissionBase
instance Control.Monad.IO.Class.MonadIO Fission.CLI.Config.Base.Types.FissionBase
instance GHC.Base.Monad Fission.CLI.Config.Base.Types.FissionBase
instance GHC.Base.Applicative Fission.CLI.Config.Base.Types.FissionBase
instance GHC.Base.Functor Fission.CLI.Config.Base.Types.FissionBase
instance Control.Monad.Logger.MonadLogger Fission.CLI.Config.Base.Types.FissionBase
instance Fission.Web.Client.Class.MonadWebClient Fission.CLI.Config.Base.Types.FissionBase
instance Control.Monad.Time.MonadTime Fission.CLI.Config.Base.Types.FissionBase
instance Fission.Authorization.ServerDID.Class.ServerDID Fission.CLI.Config.Base.Types.FissionBase
instance Fission.Web.Client.Auth.Class.MonadWebAuth Fission.CLI.Config.Base.Types.FissionBase Fission.Web.Auth.Token.Types.Token
instance Fission.Web.Client.Auth.Class.MonadWebAuth Fission.CLI.Config.Base.Types.FissionBase Crypto.PubKey.Ed25519.SecretKey
instance Network.IPFS.Local.Class.MonadLocalIPFS Fission.CLI.Config.Base.Types.FissionBase
instance RIO.Process.HasProcessContext Fission.CLI.Config.Base.Types.BaseConfig
instance RIO.Prelude.Logger.HasLogFunc Fission.CLI.Config.Base.Types.BaseConfig

module Fission.CLI.Config.Base
runBase :: MonadIO m => BaseConfig -> FissionBase a -> m a

module Fission.App.Creator.Class
class Monad m => Creator m
create :: Creator m => UserId -> CID -> UTCTime -> m (Either Errors (AppId, Subdomain))
type Errors = OpenUnion '[ServerError, AlreadyAssociated, ActionNotAuthorized App, NotFound App, ActionNotAuthorized URL, NotFound URL, Error, InvalidURL]

module Fission.App.Creator
createWithPlaceholder :: (Creator m, Initializer m) => UserId -> UTCTime -> m (Either Errors (AppId, Subdomain))
createDB :: MonadIO m => UserId -> CID -> Bytes -> UTCTime -> Transaction m AppId

module Fission.Web.App.Create
type API = Summary "Create app" :> Description "Creates a new app, assigns an initial subdomain, and sets an asset placeholder" :> PostAccepted '[JSON] URL
create :: (Initializer m, Initializer m, Creator m, MonadTime m, MonadLogger m, MonadDNSLink m) => Authorization -> ServerT API m

module Fission.App
class Monad m => Creator m
create :: Creator m => UserId -> CID -> UTCTime -> m (Either Errors (AppId, Subdomain))
createWithPlaceholder :: (Creator m, Initializer m) => UserId -> UTCTime -> m (Either Errors (AppId, Subdomain))
createDB :: MonadIO m => UserId -> CID -> Bytes -> UTCTime -> Transaction m AppId
class Monad m => Modifier m
setCID :: Modifier m => UserId -> URL -> CID -> Bool -> UTCTime -> m (Either Errors AppId)
setCidDB :: MonadIO m => UserId -> URL -> CID -> Bytes -> Bool -> UTCTime -> Transaction m (Either Errors AppId)
class Monad m => Destroyer m
destroy :: Destroyer m => UserId -> AppId -> UTCTime -> m (Either Errors [URL])
destroyByURL :: Destroyer m => UserId -> DomainName -> Maybe Subdomain -> UTCTime -> m (Either Errors [URL])
type CRUD m = (Retriever m, Creator m, Modifier m, Destroyer m)

module Fission.Web.App.Update
type API = Summary "Set app content" :> Description "Update the content (CID) for an app" :> Capture "App URL" URL :> Capture "New CID" CID :> QueryParam "copy-data" Bool :> PatchAccepted '[JSON] NoContent
update :: (MonadLogger m, MonadThrow m, MonadTime m, Modifier m) => Authorization -> ServerT API m

module Fission.Web.App.Index
type API = Summary "App index" :> Description "A list of all of your apps and their associated domain names" :> Get '[JSON] (Map AppId [URL])
index :: (MonadDB t m, Retriever t, Retriever t) => Authorization -> ServerT API m

module Fission.Web.App
type API = API :<|> API :<|> API :<|> API
server :: (Initializer m, CRUD m, Initializer m, MonadTime m, MonadLogger m, MonadDNSLink m, MonadDB t m, Retriever t, Retriever t) => Authorization -> ServerT API m

module Fission.Web.Handler

-- | Natural transformation into a RIO handler
fromHandler :: MonadIO m => Handler a -> m a

-- | Natural transformation to native Servant handler
toHandler :: (m a -> IO a) -> m a -> Handler a

module Fission.Web.Heroku.MIME.VendorJSONv3.Types
newtype VendorJSONv3
VendorJSONv3 :: Value -> VendorJSONv3
[$sel:unVendorJSONv3:VendorJSONv3] :: VendorJSONv3 -> Value
instance GHC.Show.Show Fission.Web.Heroku.MIME.VendorJSONv3.Types.VendorJSONv3
instance Servant.API.ContentTypes.Accept Fission.Web.Heroku.MIME.VendorJSONv3.Types.VendorJSONv3
instance Data.Aeson.Types.ToJSON.ToJSON a => Servant.API.ContentTypes.MimeRender Fission.Web.Heroku.MIME.VendorJSONv3.Types.VendorJSONv3 a
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Heroku.MIME.VendorJSONv3.Types.VendorJSONv3
instance Data.Aeson.Types.FromJSON.FromJSON a => Servant.API.ContentTypes.MimeUnrender Fission.Web.Heroku.MIME.VendorJSONv3.Types.VendorJSONv3 a

module Fission.Web.Heroku.Deprovision
type API = Summary "Deprovision" :> Description "Deprovision a Heroku add-on (for the Heroku partner service only)" :> Capture "addon_id" UUID :> DeleteNoContent '[VendorJSONv3] NoContent
destroy :: (MonadRemoteIPFS m, MonadLogger m, MonadDB t m, MonadLogger t, MonadThrow t, Retriever t, Destroyer t, Retriever t, Destroyer t, Retriever t, Destroyer t) => ServerT API m

module Fission.Web.IPFS.CID
type API = Summary "CID Index" :> Description "List of all of your pinned CIDs (not associated with your personal file system or apps)" :> Get '[JSON, PlainText] [CID]
allForUser :: (MonadDB t m, Retriever t) => Authorization -> ServerT API m

module Fission.Web.IPFS.DAG
type API = Summary "Pin an IPFS DAG structure" :> Description "Pin some data not associated to a user app or file system. We call these loose pins, likely to be deprecated." :> ReqBody '[PlainText, OctetStream] Serialized :> Post '[PlainText, OctetStream] CID
put :: (MonadRemoteIPFS m, MonadLocalIPFS m, MonadLogger m, MonadThrow m, MonadTime m, MonadDB t m, Creator t) => Authorization -> ServerT API m

module Fission.Web.IPFS.Download
type API = PathAPI :<|> QueryAPI
get :: (MonadLocalIPFS m, MonadLogger m, MonadThrow m) => ServerT API m

module Fission.Web.IPFS.Peer
type API = Summary "Peer index" :> Description "List of recommended IPFS peers" :> Get '[JSON, PlainText, OctetStream] (NonEmpty Peer)

-- | Get a list of valid IPFS addresses that a user could use to join our
--   network
get :: (MonadLinkedIPFS m, MonadLocalIPFS m, MonadLogger m, MonadThrow m) => ServerT API m


-- | Servant client for retrieving peer data
module Fission.Web.Client.Peers

-- | API path to the peers endpoints
type API = "ipfs" :> "peers" :> API

-- | Retrieves the Fission peer list from the server
getPeers :: (MonadUnliftIO m, MonadWebClient m) => m (Either ClientError (NonEmpty Peer))


-- | Module for connecting to the Fission IPFS service
module Fission.CLI.IPFS.Connect

-- | Connect to the Fission IPFS network with a set amount of retries
swarmConnectWithRetry :: (MonadUnliftIO m, MonadLogger m, MonadLocalIPFS m, MonadWebClient m) => Peer -> Int -> m (Either SomeException ())

-- | Create a could not connect to Fission peer message for the terminal
couldNotSwarmConnect :: MonadIO m => m ()


-- | Reading and writing local user config values
module Fission.CLI.Environment

-- | Initialize the Environment file
init :: (MonadUnliftIO m, MonadLogger m, MonadWebClient m) => m ()

-- | Gets hierarchical environment by recursing through file system
get :: MonadIO m => m Environment

-- | Get the path to the Environment file, local or global
getPath :: MonadIO m => Bool -> m FilePath

-- | Create a could not read message for the terminal
couldNotRead :: MonadIO m => m ()

-- | Removes the user's global config file
removeConfigFile :: MonadUnliftIO m => m (Either IOException ())

-- | Retrieves a Fission Peer from local config If not found we retrive
--   from the network and store
getOrRetrievePeer :: (MonadUnliftIO m, MonadLogger m, MonadWebClient m) => Environment -> m (Maybe Peer)

module Fission.Web.IPFS.Pin
type API = PinAPI :<|> UnpinAPI
type PinAPI = Summary "Pin CID" :> Description "DEPRECATED \9940 Pin an otherwise unassociated CID" :> Capture "cid" CID :> Put '[PlainText, OctetStream] NoContent
type UnpinAPI = Summary "Unpin CID" :> Description "DEPRECATED \9940 Unpin an otherwise unassociated CID" :> Capture "cid" CID :> DeleteAccepted '[PlainText, OctetStream] NoContent
server :: (MonadRemoteIPFS m, MonadLogger m, MonadThrow m, MonadTime m, MonadDB t m, Creator t, Retriever t, Destroyer t) => Authorization -> ServerT API m
pin :: (MonadRemoteIPFS m, MonadLogger m, MonadThrow m, MonadTime m, MonadDB t m, Creator t) => UserId -> ServerT PinAPI m
unpin :: (MonadRemoteIPFS m, MonadLogger m, MonadThrow m, MonadDB t m, Retriever t, Destroyer t) => UserId -> ServerT UnpinAPI m

module Fission.Web.IPFS.Upload
type API = Summary "Upload file" :> Description "Directly upload a file over HTTP" :> ReqBody '[PlainText, OctetStream] Serialized :> Post '[PlainText, OctetStream] CID
add :: (MonadLocalIPFS m, MonadRemoteIPFS m, MonadLogger m, MonadThrow m, MonadTime m, MonadDB t m, Creator t) => Authorization -> ServerT API m

module Fission.Web.IPFS
type API = AuthedAPI :<|> PublicAPI
type Auth = HigherOrder
type AuthedAPI = Auth :> UnauthedAPI
type PublicAPI = "peers" :> API :<|> API
type UnauthedAPI = "cids" :> API :<|> API :<|> API :<|> "dag" :> API
authed :: (MonadRemoteIPFS m, MonadLocalIPFS m, MonadLogger m, MonadThrow m, MonadTime m, MonadDB t m, Creator t, Retriever t, Destroyer t) => ServerT AuthedAPI m
public :: (MonadLinkedIPFS m, MonadLocalIPFS m, MonadLogger m, MonadThrow m) => ServerT PublicAPI m
server :: (MonadRemoteIPFS m, MonadLinkedIPFS m, MonadLocalIPFS m, MonadLogger m, MonadThrow m, MonadTime m, MonadDB t m, Creator t, Retriever t, Destroyer t) => ServerT API m

module Fission.Web.Log
rioApacheLogger :: MonadLogger m => Request -> Status -> Maybe Integer -> m ()
fromLogFunc :: LogFunc -> ApacheLogger

module Fission.Web.Middleware.CORS
allowedMethods :: [Method]
allowedRequestHeaders :: [HeaderName]
middleware :: Middleware
policy :: CorsResourcePolicy

module Fission.Web.Ping.Types

-- | A dead-simple text wrapper. Primarily exists for customized instances.
newtype Pong
Pong :: Text -> Pong
[$sel:unPong:Pong] :: Pong -> Text
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Ping.Types.Pong
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Ping.Types.Pong
instance Data.String.IsString Fission.Web.Ping.Types.Pong
instance GHC.Show.Show Fission.Web.Ping.Types.Pong
instance GHC.Classes.Eq Fission.Web.Ping.Types.Pong
instance Data.Swagger.Internal.Schema.ToSchema Fission.Web.Ping.Types.Pong
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Fission.Web.Ping.Types.Pong

module Fission.Web.Ping
type API = Summary "Simple Ping" :> Description "A quick way to check for liveness" :> Get '[JSON, PlainText] Pong
pong :: Pong

module Fission.Web.Redirect
redirect :: MonadThrow m => ByteString -> m ()

module Fission.Web.Swagger.Auth
fissionSecurity :: SecurityScheme

module Fission.Internal.Orphanage.RegisterDid
instance Servant.Swagger.Internal.HasSwagger api => Servant.Swagger.Internal.HasSwagger (Fission.Web.Auth.Types.RegisterDID Servant.API.Sub.:> api)

module Fission.Internal.Orphanage.HigherOrder
instance Servant.Swagger.Internal.HasSwagger api => Servant.Swagger.Internal.HasSwagger (Fission.Web.Auth.Types.HigherOrder Servant.API.Sub.:> api)

module Fission.Web.Tls
run :: Manager -> ClientM a -> String -> IO (Either ClientError a)
url :: String -> BaseUrl

module Fission.Web.Types

-- | The hostname of the running application
newtype Host
Host :: BaseUrl -> Host
[$sel:getHost:Host] :: Host -> BaseUrl

-- | Port of the running application
newtype Port
Port :: Port -> Port
[$sel:port:Port] :: Port -> Port
getRawHost :: Host -> String
instance GHC.Generics.Generic Fission.Web.Types.Port
instance GHC.Classes.Eq Fission.Web.Types.Port
instance GHC.Show.Show Fission.Web.Types.Port
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Types.Host
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.Types.Host
instance GHC.Classes.Eq Fission.Web.Types.Host
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.Types.Port
instance GHC.Show.Show Fission.Web.Types.Host

module Fission.Web.Server.Reflective.Class
class Monad m => MonadReflectiveServer m
getHost :: MonadReflectiveServer m => m Host

module Fission.Web.Server.Reflective

module Fission.Web.Heroku.Provision
type API = Summary "Provision" :> Description "Provision a new Heroku add-on (for the Heroku partner service only)" :> ReqBody '[JSON] Request :> Post '[VendorJSONv3] Provision
create :: (MonadIO m, MonadThrow m, MonadLogger m, MonadLocalIPFS m, MonadReflectiveServer m, Creator m) => ServerT API m

module Fission.Web.Heroku
type API = API :<|> API
server :: (MonadReflectiveServer m, MonadRemoteIPFS m, MonadLocalIPFS m, MonadLogger m, MonadThrow m, Creator m, MonadDB t m, MonadLogger t, MonadThrow t, Retriever t, Destroyer t, Retriever t, Destroyer t, Destroyer t, Retriever t) => ServerT API m

module Fission.Internal.Mock.Types

-- | Fission's mock type
--   
--   Notes: * We will likely want <tt>State</tt> in here at some stage *
--   <tt>RIO</tt> because lots of constraints want <tt>MonadIO</tt> * Avoid
--   actual <tt>IO</tt>, or we're going to have to rework this ðŸ˜‰
newtype Mock effs a
Mock :: WriterT [OpenUnion effs] (RIO Config) a -> Mock effs a
[$sel:unMock:Mock] :: Mock effs a -> WriterT [OpenUnion effs] (RIO Config) a
instance Control.Monad.Catch.MonadCatch (Fission.Internal.Mock.Types.Mock effs)
instance Control.Monad.Catch.MonadThrow (Fission.Internal.Mock.Types.Mock effs)
instance Control.Monad.IO.Class.MonadIO (Fission.Internal.Mock.Types.Mock effs)
instance Control.Monad.Reader.Class.MonadReader Fission.Internal.Mock.Config.Types.Config (Fission.Internal.Mock.Types.Mock effs)
instance Control.Monad.Writer.Class.MonadWriter [Data.WorldPeace.Union.OpenUnion effs] (Fission.Internal.Mock.Types.Mock effs)
instance GHC.Base.Monad (Fission.Internal.Mock.Types.Mock effs)
instance GHC.Base.Applicative (Fission.Internal.Mock.Types.Mock effs)
instance GHC.Base.Functor (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RunDB effs => Fission.Internal.MonadDB.Class.MonadDB (Fission.Internal.Mock.Types.Mock effs) (Fission.Internal.Mock.Types.Mock effs)
instance Fission.IPFS.Linked.Class.MonadLinkedIPFS (Fission.Internal.Mock.Types.Mock effs)
instance Fission.Web.Auth.Token.Basic.Class.MonadBasicAuth GHC.Base.String (Fission.Internal.Mock.Types.Mock effs)
instance Fission.Web.Auth.Token.Basic.Class.MonadBasicAuth Fission.Platform.Heroku.Auth.Types.Auth (Fission.Internal.Mock.Types.Mock effs)
instance Fission.Web.Auth.Class.MonadAuth Fission.User.DID.Types.DID (Fission.Internal.Mock.Types.Mock effs)
instance Fission.Web.Auth.Class.MonadAuth (Database.Persist.Class.PersistEntity.Entity Fission.Models.User) (Fission.Internal.Mock.Types.Mock effs)
instance Fission.Web.Auth.Class.MonadAuth Fission.Authorization.Types.Authorization (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RunAWS effs => Network.AWS.MonadAWS (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.CheckTime effs => Control.Monad.Time.MonadTime (Fission.Internal.Mock.Types.Mock effs)
instance (Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RunAWS effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.UpdateRoute53 effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.ClearRoute53 effs) => Fission.AWS.Route53.Class.MonadRoute53 (Fission.Internal.Mock.Types.Mock effs)
instance (Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.UpdateRoute53 effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.ClearRoute53 effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.SetDNSLink effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.FollowDNSLink effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RunAWS effs) => Fission.IPFS.DNSLink.Class.MonadDNSLink (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RunLocalIPFS effs => Network.IPFS.Local.Class.MonadLocalIPFS (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RunRemoteIPFS effs => Network.IPFS.Remote.Class.MonadRemoteIPFS (Fission.Internal.Mock.Types.Mock effs)
instance Fission.Web.Server.Reflective.Class.MonadReflectiveServer (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.LogMsg effs => Control.Monad.Logger.MonadLogger (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.DestroyHerokuAddOn effs => Fission.Platform.Heroku.AddOn.Destroyer.Class.Destroyer (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.DestroyHerokuAddOn effs => Fission.Platform.Heroku.AddOn.Retriever.Class.Retriever (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.CreateHerokuAddOn effs => Fission.Platform.Heroku.AddOn.Creator.Class.Creator (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RetrieveUser effs => Fission.User.Retriever.Class.Retriever (Fission.Internal.Mock.Types.Mock effs)
instance (Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.CreateHerokuAddOn effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.CreateUser effs, Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.UpdateRoute53 effs) => Fission.User.Creator.Class.Creator (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.ModifyUser effs => Fission.User.Modifier.Class.Modifier (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.DestroyUser effs => Fission.User.Destroyer.Class.Destroyer (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.RetrieveLoosePin effs => Fission.LoosePin.Retriever.Class.Retriever (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.CreateLoosePin effs => Fission.LoosePin.Creator.Class.Creator (Fission.Internal.Mock.Types.Mock effs)
instance Data.WorldPeace.Union.IsMember Fission.Internal.Mock.Effect.Types.DestroyLoosePin effs => Fission.LoosePin.Destroyer.Class.Destroyer (Fission.Internal.Mock.Types.Mock effs)
instance Fission.Web.Client.Auth.Class.MonadWebAuth (Fission.Internal.Mock.Types.Mock effs) Fission.Authorization.Types.Authorization

module Fission.Internal.Mock

-- | Run the action described by a <tt>Mock</tt>
runMock :: MonadIO m => Config -> Mock effs a -> m (Session effs a)
runMockIO' :: Mock effs a -> IO a
runMockIO :: MonadIO m => Config -> Mock effs a -> m a


-- | Configuration types
module Fission.Config.Types

-- | The top level <tt>Fission</tt> application <a>RIO</a> configuration
data Config
Config :: !ProcessContext -> !LogFunc -> !Manager -> !Manager -> !Pool SqlBackend -> !BinPath -> !URL -> !Peer -> !Timeout -> !ID -> !Password -> !AccessKey -> !SecretKey -> !MockRoute53 -> !DomainName -> !ZoneID -> !CID -> !DomainName -> !ZoneID -> !CID -> !ApiKey -> !Host -> !TemplateId -> !Host -> !DID -> !ZoneID -> !URL -> Config
[$sel:processCtx:Config] :: Config -> !ProcessContext
[$sel:logFunc:Config] :: Config -> !LogFunc
[$sel:httpManager:Config] :: Config -> !Manager
[$sel:tlsManager:Config] :: Config -> !Manager
[$sel:dbPool:Config] :: Config -> !Pool SqlBackend
[$sel:ipfsPath:Config] :: Config -> !BinPath
[$sel:ipfsURL:Config] :: Config -> !URL
[$sel:ipfsRemotePeer:Config] :: Config -> !Peer
[$sel:ipfsTimeout:Config] :: Config -> !Timeout
[$sel:herokuID:Config] :: Config -> !ID
[$sel:herokuPassword:Config] :: Config -> !Password
[$sel:awsAccessKey:Config] :: Config -> !AccessKey
[$sel:awsSecretKey:Config] :: Config -> !SecretKey
[$sel:awsMockRoute53:Config] :: Config -> !MockRoute53
[$sel:baseAppDomain:Config] :: Config -> !DomainName
[$sel:baseAppZoneID:Config] :: Config -> !ZoneID
[$sel:appPlaceholder:Config] :: Config -> !CID
[$sel:userRootDomain:Config] :: Config -> !DomainName
[$sel:userZoneID:Config] :: Config -> !ZoneID
[$sel:defaultDataCID:Config] :: Config -> !CID
[$sel:sibApiKey:Config] :: Config -> !ApiKey
[$sel:sibUrl:Config] :: Config -> !Host
[$sel:sibTemplateId:Config] :: Config -> !TemplateId
[$sel:host:Config] :: Config -> !Host
[$sel:fissionDID:Config] :: Config -> !DID
[$sel:serverZoneID:Config] :: Config -> !ZoneID
[$sel:liveDriveURL:Config] :: Config -> !URL
instance GHC.Show.Show Fission.Config.Types.Config
instance RIO.Process.HasProcessContext Fission.Config.Types.Config
instance RIO.Prelude.Logger.HasLogFunc Fission.Config.Types.Config

module Fission.Web.User.Create
type API = Summary "Create user with DID and UCAN proof" :> Description "Register a new user (must auth with user-controlled DID)" :> ReqBody '[JSON] Registration :> PutCreated '[JSON] NoContent
type PasswordAPI = Summary "Create user with password" :> Description "DEPRECATED \9940 Register a new user (must auth with user-controlled DID)" :> ReqBody '[JSON] Registration :> PostCreated '[JSON] ()
withDID :: (MonadDNSLink m, MonadLogger m, MonadTime m, MonadEmail m, Creator m, Creator m) => DID -> ServerT API m
withPassword :: (MonadDNSLink m, MonadLogger m, MonadTime m, MonadEmail m, Creator m, Creator m) => ServerT PasswordAPI m

module Fission.Web.User.Password.Reset.Types
newtype Reset
Reset :: Maybe Password -> Reset
[$sel:maybePassword:Reset] :: Reset -> Maybe Password
instance GHC.Show.Show Fission.Web.User.Password.Reset.Types.Reset
instance Test.QuickCheck.Arbitrary.Arbitrary Fission.Web.User.Password.Reset.Types.Reset
instance Data.Aeson.Types.ToJSON.ToJSON Fission.Web.User.Password.Reset.Types.Reset
instance Data.Aeson.Types.FromJSON.FromJSON Fission.Web.User.Password.Reset.Types.Reset
instance Data.Swagger.Internal.Schema.ToSchema Fission.Web.User.Password.Reset.Types.Reset

module Fission.Web.User.Password.Reset
type API = Summary "Reset password" :> Description "DEPRECATED \9940 Reset password" :> ReqBody '[JSON] Reset :> Put '[JSON] Password
server :: (MonadThrow m, MonadLogger m, MonadTime m, MonadIO m, Modifier m) => Authorization -> ServerT API m

module Fission.Web.User.UpdateData
type API = Summary "Update data root" :> Description "Set/update currently authenticated user's file system content" :> Capture "newCID" CID :> PatchNoContent '[PlainText, OctetStream, JSON] NoContent
server :: (MonadLogger m, MonadThrow m, MonadTime m, Modifier m) => Authorization -> ServerT API m

module Fission.Web.User.UpdateExchangeKeys
type API = AddAPI :<|> RemoveAPI
type AddAPI = Summary "Add Public Exchange Key" :> Description "Add a key to the currently authenticated user's root list of public exchange keys" :> Capture "did" PublicKey :> Put '[JSON] [PublicKey]
type RemoveAPI = Summary "Remove Public Exchange Key" :> Description "Remove a key from the currently authenticated user's root list of public exchange keys" :> Capture "did" PublicKey :> Delete '[JSON] [PublicKey]
server :: (MonadTime m, MonadLogger m, MonadThrow m, Modifier m) => Authorization -> ServerT API m
addKey :: (MonadTime m, MonadLogger m, MonadThrow m, Modifier m) => UserId -> ServerT AddAPI m
removeKey :: (MonadTime m, MonadLogger m, MonadThrow m, Modifier m) => UserId -> ServerT RemoveAPI m

module Fission.Web.User.UpdatePublicKey
type API = Summary "Update Public Key" :> Description "Set currently authenticated user's root public key to another one" :> ReqBody '[JSON] Public :> Patch '[PlainText, OctetStream, JSON] NoContent
server :: (MonadTime m, MonadLogger m, MonadThrow m, Modifier m) => Authorization -> ServerT API m

module Fission.Web.User.Verify
type API = Summary "Validate auth" :> Description "DEPRECATED \9940 Verify user auth -- prefer /user/whoami" :> Get '[JSON] Bool
server :: Monad m => ServerT API m

module Fission.Web.User.VerifyEmail
type API = Summary "Email verification" :> Description "" :> Capture "Challenge" Challenge :> Get '[JSON] ()
server :: (MonadThrow m, MonadLogger m, Verifier m) => ServerT API m

module Fission.Web.User.WhoAmI
type API = Summary "Get username" :> Description "Get username registered to currently authenticated user" :> Get '[PlainText, JSON] Username
server :: Monad m => Authorization -> ServerT API m

module Fission.Web.User
type API = RegisterRoute :<|> PasswordAPI :<|> WhoAmIRoute :<|> VerifyRoute :<|> VerifyEmailRoute :<|> UpdatePublicKeyRoute :<|> UpdateExchangeKeysRoute :<|> UpdateDataRoute :<|> ResetRoute
type Auth = HigherOrder
type RegisterRoute = RegisterDID :> API
type VerifyRoute = "verify" :> Auth :> API
type VerifyEmailRoute = "email" :> "verify" :> API
type UpdatePublicKeyRoute = "did" :> Auth :> API
type ResetRoute = "reset_password" :> Auth :> API
type WhoAmIRoute = "whoami" :> Auth :> API
server :: (MonadDNSLink m, MonadLogger m, MonadTime m, MonadEmail m, Modifier m, Creator m, Creator m, Verifier m) => ServerT API m


-- | Top-level router type for the application
module Fission.Web.Routes
type API = IPFSRoute :<|> AppRoute :<|> HerokuRoute :<|> UserRoute :<|> PingRoute :<|> DNSRoute
type UserPrefix = "user"
type UserRoute = UserPrefix :> API
type HerokuRoute = "heroku" :> "resources" :> HerokuAddOnAPI :> API
type IPFSPrefix = "ipfs"
type IPFSRoute = IPFSPrefix :> API
type PingRoute = "ping" :> API
type DNSRoute = "dns" :> HigherOrder :> API
type AppRoute = AppPrefix :> HigherOrder :> API
type AppPrefix = "app"

module Fission.Web.Swagger
type API = SwaggerSchemaUI "docs" "docs.json"
server :: (forall a. Handler a -> m a) -> Host -> ServerT API m

module Fission.Web.Client.IPFS
type DAGPut = AuthedIPFS ("dag" :> API)
type Unpin = AuthedIPFS UnpinAPI
type Pin = AuthedIPFS PinAPI
type Upload = AuthedIPFS API
type CIDs = AuthedIPFS ("cids" :> API)


-- | Pin files via the CLI
module Fission.CLI.IPFS.Pin
add :: (MonadUnliftIO m, MonadTime m, MonadLogger m, MonadWebClient m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => CID -> m (Either ClientError CID)

module Fission.Web.Client.App
type Create = AppPrefix :> HigherOrder :> API
type Update = AppPrefix :> HigherOrder :> API
mkUpdateReq :: (MonadIO m, MonadTime m, MonadLogger m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => URL -> CID -> Bool -> m (ClientM NoContent)


-- | Initialize a new Fission app in an existing directory
module Fission.CLI.Command.App.Init
cmd :: (MonadWebClient m, MonadIO m, MonadTime m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey, MonadLogger m) => Command m Options ()
cmdTxt :: Text

-- | Sync the current working directory to the server over IPFS
appInit :: (MonadWebClient m, MonadIO m, MonadTime m, MonadLogger m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => Options -> m ()


-- | Continuous file sync
module Fission.CLI.Command.Watch

-- | The command to attach to the CLI tree
cmd :: (MonadUnliftIO m, MonadLogger m, MonadLocalIPFS m, MonadEnvironment m, MonadWebClient m, MonadTime m, MonadWebAuth m Token, MonadWebAuth m SecretKey, ServerDID m) => (m () -> IO ()) -> Command m Options ()
handleTreeChanges :: (MonadUnliftIO m, MonadLogger m, MonadTime m, MonadLocalIPFS m, MonadWebClient m, MonadWebAuth m Token, MonadWebAuth m SecretKey, ServerDID m) => (m () -> IO ()) -> URL -> Bool -> MVar UTCTime -> MVar Text -> WatchManager -> FilePath -> IO StopListening

-- | Continuously sync the current working directory to the server over
--   IPFS
watcher :: (MonadUnliftIO m, MonadLogger m, MonadLocalIPFS m, MonadEnvironment m, MonadWebClient m, MonadTime m, MonadWebAuth m Token, MonadWebAuth m SecretKey, ServerDID m) => (m () -> IO ()) -> Options -> m ()


-- | File sync, IPFS-style
module Fission.CLI.Command.Up

-- | The command to attach to the CLI tree
cmd :: (MonadUnliftIO m, MonadLogger m, MonadLocalIPFS m, MonadEnvironment m, MonadWebClient m, MonadTime m, MonadWebAuth m Token, MonadWebAuth m SecretKey, ServerDID m) => Command m Options ()

-- | Sync the current working directory to the server over IPFS
up :: (MonadUnliftIO m, MonadLogger m, MonadLocalIPFS m, MonadEnvironment m, MonadWebClient m, MonadTime m, MonadWebAuth m Token, MonadWebAuth m SecretKey, ServerDID m) => Options -> m ()

module Fission.Internal.API
mkLink :: (IsElem route API, HasLink route) => Proxy route -> MkLink route Link


-- | Update DNS via the CLI
module Fission.CLI.DNS
update :: (MonadUnliftIO m, MonadLogger m, MonadWebClient m, MonadTime m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => CID -> m (Either ClientError DomainName)

module Fission.Web.Client.User
type Register = UserPrefix :> RegisterRoute
type Verify = UserPrefix :> VerifyRoute
type WhoAmI = UserPrefix :> WhoAmIRoute
type UpdatePK = UserPrefix :> UpdatePublicKeyRoute


-- | Guards to ensure we have the appropriate data available to run a
--   protected action
module Fission.CLI.Config.Connected

-- | Ensure we have a local config file with the appropriate data
--   
--   Takes a <tt>Connected</tt>-dependant action, and lifts it into an
--   environment that contains a superset of the environment
runConnected :: MonadIO m => BaseConfig -> FissionConnected a -> m (Either Error a)
runConnected' :: MonadIO m => ConnectedConfig -> FissionConnected a -> m a
liftConfig :: (MonadUnliftIO m, MonadLocalIPFS m, MonadLogger m, MonadWebClient m, ServerDID m) => BaseConfig -> m (Either Error ConnectedConfig)


-- | Whoami command
module Fission.CLI.Command.Whoami

-- | The command to attach to the CLI tree
cmd :: (MonadIO m, MonadTime m, MonadLogger m, MonadWebClient m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => Command m () ()
whoami :: (MonadIO m, MonadTime m, MonadLogger m, MonadWebClient m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => m ()


-- | Setup command
module Fission.CLI.Command.Setup

-- | The command to attach to the CLI tree
cmd :: (MonadIO m, MonadLogger m, MonadWebClient m, MonadTime m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => Command m () ()
setup :: (MonadIO m, MonadLogger m, MonadWebClient m, MonadTime m, ServerDID m, MonadWebAuth m Token, MonadWebAuth m SecretKey) => m ()

module Fission.CLI
cli :: MonadIO m => BaseConfig -> m ()

module Fission.Challenge
verificationLink :: Challenge -> Text


-- | Top level web application and API
module Fission.Web

-- | Top level web API type. Handled by <a>server</a>.
type API = API :<|> API
app :: (Initializer m, Initializer m, CRUD m, MonadReflectiveServer m, MonadLinkedIPFS m, MonadRemoteIPFS m, MonadLocalIPFS m, MonadDNSLink m, MonadLogger m, MonadTime m, MonadEmail m, CRUD m, Creator m, Verifier m, MonadDB t m, MonadLogger t, MonadThrow t, CRUD t, CRUD t, Retriever t, Destroyer t, Retriever t, Retriever t) => (forall a. m a -> Handler a) -> Context Checks -> Host -> Application

-- | Web handlers for the <a>API</a>
server :: (Initializer m, Initializer m, CRUD m, MonadReflectiveServer m, MonadLinkedIPFS m, MonadRemoteIPFS m, MonadLocalIPFS m, MonadDNSLink m, MonadLogger m, MonadTime m, MonadEmail m, CRUD m, Creator m, Verifier m, MonadDB t m, MonadLogger t, MonadThrow t, CRUD t, CRUD t, Retriever t, Destroyer t, Retriever t, Retriever t) => Host -> ServerT API m
bizServer :: (Initializer m, Initializer m, CRUD m, MonadReflectiveServer m, MonadLinkedIPFS m, MonadRemoteIPFS m, MonadLocalIPFS m, MonadDNSLink m, MonadLogger m, MonadTime m, MonadEmail m, CRUD m, Creator m, Verifier m, MonadDB t m, MonadLogger t, MonadThrow t, CRUD t, CRUD t, Retriever t, Destroyer t, Retriever t, Retriever t) => ServerT API m

module Fission.Types

-- | The top-level app type
newtype Fission a
Fission :: RIO Config a -> Fission a
[$sel:unFission:Fission] :: Fission a -> RIO Config a
instance Control.Monad.Catch.MonadMask Fission.Types.Fission
instance Control.Monad.Catch.MonadCatch Fission.Types.Fission
instance Control.Monad.Catch.MonadThrow Fission.Types.Fission
instance Control.Monad.Reader.Class.MonadReader Fission.Config.Types.Config Fission.Types.Fission
instance Control.Monad.IO.Unlift.MonadUnliftIO Fission.Types.Fission
instance Control.Monad.IO.Class.MonadIO Fission.Types.Fission
instance GHC.Base.Monad Fission.Types.Fission
instance GHC.Base.Applicative Fission.Types.Fission
instance GHC.Base.Functor Fission.Types.Fission
instance Control.Monad.Logger.MonadLogger Fission.Types.Fission
instance Control.Monad.Time.MonadTime Fission.Types.Fission
instance Fission.Web.Server.Reflective.Class.MonadReflectiveServer Fission.Types.Fission
instance Fission.Internal.MonadDB.Class.MonadDB (Fission.Internal.MonadDB.Types.Transaction Fission.Types.Fission) Fission.Types.Fission
instance Network.AWS.MonadAWS Fission.Types.Fission
instance Fission.AWS.Route53.Class.MonadRoute53 Fission.Types.Fission
instance Fission.IPFS.DNSLink.Class.MonadDNSLink Fission.Types.Fission
instance Fission.IPFS.Linked.Class.MonadLinkedIPFS Fission.Types.Fission
instance Network.IPFS.Local.Class.MonadLocalIPFS Fission.Types.Fission
instance Network.IPFS.Remote.Class.MonadRemoteIPFS Fission.Types.Fission
instance Fission.Web.Auth.Token.Basic.Class.MonadBasicAuth Fission.Platform.Heroku.Auth.Types.Auth Fission.Types.Fission
instance Fission.Web.Auth.Class.MonadAuth Fission.User.DID.Types.DID Fission.Types.Fission
instance Fission.Web.Auth.Class.MonadAuth Fission.Authorization.Types.Authorization Fission.Types.Fission
instance Fission.App.Domain.Initializer.Class.Initializer Fission.Types.Fission
instance Fission.App.Content.Initializer.Class.Initializer Fission.Types.Fission
instance Fission.Web.Auth.Token.JWT.Resolver.Class.Resolver Fission.Types.Fission
instance Fission.Authorization.ServerDID.Class.ServerDID Fission.Types.Fission
instance Fission.Authorization.ServerDID.Class.PublicizeServerDID Fission.Types.Fission
instance Fission.User.Retriever.Class.Retriever Fission.Types.Fission
instance Fission.User.Creator.Class.Creator Fission.Types.Fission
instance Fission.User.Modifier.Class.Modifier Fission.Types.Fission
instance Fission.User.Destroyer.Class.Destroyer Fission.Types.Fission
instance Fission.App.Retriever.Class.Retriever Fission.Types.Fission
instance Fission.App.Creator.Class.Creator Fission.Types.Fission
instance Fission.App.Modifier.Class.Modifier Fission.Types.Fission
instance Fission.App.Destroyer.Class.Destroyer Fission.Types.Fission
instance Fission.Platform.Heroku.AddOn.Creator.Class.Creator Fission.Types.Fission
instance Fission.Domain.Retriever.Class.Retriever Fission.Types.Fission
instance Fission.Domain.Creator.Class.Creator Fission.Types.Fission
instance Fission.Challenge.Creator.Class.Creator Fission.Types.Fission
instance Fission.Challenge.Verifier.Class.Verifier Fission.Types.Fission
instance Fission.Email.Class.MonadEmail Fission.Types.Fission

module Fission

-- | Run actions described by a <tt>Fission</tt> type
runFission :: MonadIO m => Config -> Fission a -> m a
